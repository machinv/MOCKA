(*!m2pim+mocka*)

(* ------------------------------------------------------------------------ *
 * MOCKA Modula-2 Compiler System, Version 1807                             *
 *                                                                          *
 * Copyright (C) 1988-2000 by                                               *
 *  GMD Gesellschaft fuer Mathematik und Datenverarbeitung,                 *
 *  Ehemalige GMD Forschungsstelle an der Uni Karlsruhe;                    *
 *  [EN] German National Research Center for Computer Science,              *
 *  Former GMD Research Lab at the University of Karlsruhe.                 *
 *                                                                          *
 * Copyright (C) 2001-2018 by                                               *
 *  Fraunhofer-Gesellschaft zur Foerderung der angewandten Forschung;       *
 *  [EN] Fraunhofer Society for the Advancement of Applied Research.        *
 * ------------------------------------------------------------------------ *)

IMPLEMENTATION MODULE Emit;

(* ************************************************************************ *
 *                  This module was generated by BEG V1.84                  *
 * ************************************************************************ *)

(* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 *                     !!! FILE MODIFICATION NOTICE !!!
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * The following manual modifications were made to this file.
 *
 * (0) added procedure header comments for visual cues
 *     and reformatted various code for readability
 *
 * (1) the unqualified import list from module CgAssOut was replaced by
 *     qualified import of replacement module CodeGen.
 *
 * (2) identifiers imported from module CgAssOut were replaced as follows:
 *
 *     s/AssOpen/CodeGen.Open/
 *     s/AssClose/CodeGen.AssClose/
 *     s/AssLn/CodeGen.EmitLn/
 *     s/AssChar/CodeGen.EmitChar/
 *     s/AssString/CodeGen.EmitString/
 *     s/AssHString/CodeGen.EmitString/
 *     s/AssInt/CodeGen.EmitInt/
 *
 *     where s/x/y/ is sed notation for replacing x with y (see: man sed)
 *
 * (3) all occurrences of EmitString with only a single character argument
 *     were replaced by EmitChar.
 *
 * (4) all occurences of EmitChar with a quoted ASCII TAB character as
 *     argument were replaced by EmitTab.
 *
 * (5) local identifiers prefixed with 'Ass' were renamed as follows:
 *
 *     s/AssRegister/EmitRegister/
 *     s/AssRegister2/EmitRegister2/
 *     s/AssWordRegister/EmitWordRegister/
 *     s/AssIntPlus//EmitIntPlus/
 *     s/AssMemAdr/EmitMemAdr/
 *     s/AssAdrMode/EmitAdrMode/
 *     s/AssSuffix/EmitSuffix/
 *     s/AssSigned/EmitSigned/
 *
 * (6) renamed constant Kommentar to EmitAnnotations.
 *
 * (7) added new procedure EmitMovReg to replace LR.
 *
 * (8) added new procedure EmitProcDecl to replace DeclareProcedure.
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ *)

IMPORT IR;

IMPORT RegAlloc;
FROM RegAlloc IMPORT
  Spilllocation, Action;

(******* empty insertion IpInOut *******)

FROM InOut IMPORT
  Write, WriteLn, WriteInt, WriteCard, WriteString;

FROM IR IMPORT
  PrintRegister, PrintINTEGER, PrintCARDINAL, PrintBOOLEAN;

(*++++++ start insertion IpTestImport ++++++*)

FROM Prints IMPORT
  PrintCHAR,PrintSHORTCARD, PrintLONGCARD, PrintSHORTINT,
  PrintLONGINT, PrintREAL, PrintLONGREAL, PrintBITSET, PrintADDRESS,
  PrintDataTempo, PrintAddressTempo, PrintSysProc, PrintLabelList,
  PrintLabel, PrintMode, PrintString, PrintStringIndex, PrintProcIndex,
  PrintRelation, PrintModuleIndex, PrintRelSymb, PrintMemAdr, PrintAdrMode;

(*------ end   insertion IpTestImport ------*)

FROM IR IMPORT
  NonTerminal, RegisterSet, Register;

(*++++++ start insertion IpNtTypes ++++++*)

FROM IR IMPORT
  MemAdr, AdrMode, AdrModeMode;

(*------ end   insertion IpNtTypes ------*)

(******* empty insertion IpText *******)

(*++++++ start insertion IpTypes ++++++*)

IMPORT CgBase;

FROM Strings IMPORT String;

(*------ end   insertion IpTypes ------*)

(*++++++ start insertion IpEmit_i ++++++*)

FROM SysLib IMPORT exit;

FROM BasicIO IMPORT Erase;

FROM SuBase IMPORT
  BuildLibraryFileName, KindAssemblerSourceFile,
  FileName, AssemblerScript, LibraryDirectory,
  DefineOption, Enabled, DebugOption, SystemCommand;

FROM SuErrors IMPORT
  ERROR, CompilerError, UndefSourcePos, OK;

FROM GcgStorage IMPORT ALLOCATE;

FROM CgBase IMPORT
  Tempo, Mode, SysProc, Relation,
  MakeRelSymb, GetLabel, ElfOption, InitCgBase;

FROM CgTypeMap IMPORT
  CprocNumber, CompUnitProcNumber,
  ByteSize, WordSize, LongSize, SizeREAL, SizeLONGREAL;

FROM CgMobil IMPORT UndefOperand;

FROM CgUtilities IMPORT
  StringAssign, StringLength,
  StringAppend1, StringAppend2, StringConcat2,
  ConvertLONGINTtoString, ConvertREALtoString, IsPowerOfTwo, Log2;

(* FROM CgAssOut IMPORT
     AssInt, AssLn, AssChar, AssString, AssHString, AssOpen, AssClose;
   replaced by: IMPORT CodeGen; below ... *)

IMPORT CodeGen, CodeGenX86;

(* Control lines for the dottool: *)
















TYPE	RoundMode	 = (RndNearest, RndZero, RndInf, RndNegInf, RndUnknown);

CONST	MaxDisplay	 = 15;		(* Max. nesting Level of procedures *)
	MaxFloatTempo	 = 64;		(* Max. size of Float-Stack	    *)
	MaxPowerTable	 = 31;
	NoTempo		 = 1111111111;
	EmitAnnotations	 = FALSE;	(* Annotations on/off *)

VAR
    RelationTable    : ARRAY CgBase.Relation OF
			 ARRAY [FALSE..TRUE] OF ARRAY [0..2] OF CHAR;
			   (* maps Relation into e,ne,g,ge,l,le,a,ae,b,be  *)

    Reverse	     : ARRAY CgBase.Relation OF CgBase.Relation;
			   (* maps Relation into reverse Relation	   *)

    PowerTable       : ARRAY [0 .. MaxPowerTable] OF LONGINT;
                           (* powers of two, 1 <= 2^n <= 2^MaxPowerTable   *)

    WordReg, ByteReg : ARRAY Register OF ARRAY [0..4] OF CHAR;
			   (* maps to register parts                       *)

    SaveDisplay	     : ARRAY [0 .. MaxDisplay] OF BOOLEAN;
                           (* SaveDisplay [i] = TRUE <==> save display of  *)
                           (* current procedure level                      *)

    FStackTempo	     : ARRAY [0 .. MaxFloatTempo-1] OF CgBase.Tempo;
			   (* temporaries if FloatingPoint-Stack overflows *)

    TransferTempo    : CgBase.Tempo;
			   (* temporary for reg <-> freg transfers *)

    oEmitIR, oEmitMatch, oRegAlloc, oAssemblerListing, oCCall : CARDINAL;

    AsmListFileName	: FileName;
    ModName		: ARRAY [0..80] OF CHAR;

    CurFrameSize	: LONGINT;
    CurRoundMode	: RoundMode;

    CurFStackSize	: INTEGER;
    FStackStart		: INTEGER;

    ProcLabel		: CgBase.Label;

(* local Variables for Emit-Routines *)
VAR
	lab, lab2	: CgBase.Label;
	i,j             : LONGINT;
	k		: SHORTCARD;
	str, cmd        : ARRAY [0..255] OF CHAR;
	ok		: BOOLEAN;
	tr1		: RECORD
			    CASE : BOOLEAN OF
			    | TRUE : r : REAL;
			    | FALSE : c : LONGINT;
			    END;
			  END;
	tr2		: RECORD
			    CASE : BOOLEAN OF
			    | TRUE : r : LONGREAL;
			    | FALSE : c2, c1 : LONGINT;
			    END;
			  END;


(* ------------------------------------------------------------------------
 * Public procedure EmitMovReg(dest, source)
 * ------------------------------------------------------------------------
 * Emits a register to register move instruction where 'source' is the
 * source register and 'dest' is the destination register.
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitMovReg ( dest, source : Register );

(* Replacement for LR *)

BEGIN
  IF EmitAnnotations THEN
    CodeGen.EmitTab;
    CodeGen.EmitString("/* MovReg */");
    CodeGen.EmitLn
  END; (* IF *)

  (* opcode *)
  CodeGen.EmitTab;
  CodeGen.EmitString("movl");

  (* first operand *)
  CodeGen.EmitTab;
  EmitRegister(source);

  (* second operand*)
  CodeGen.EmitString(", ");
  EmitRegister(dest);

  (* eol *)
  CodeGen.EmitLn
END EmitMovReg;

(* ------------------------------------------------------------------------
 * Obsolete procedure LR(to, from)  --  replaced by EmitMovReg
 * ------------------------------------------------------------------------ *)

PROCEDURE LR ( to, from : Register );
(*  Copy Register from into Register to *)
BEGIN
  CodeGen.EmitString(' 	movl	');
  EmitRegister(from);
  CodeGen.EmitString(', ');
  EmitRegister(to);
  CodeGen.EmitLn;

  IF EmitAnnotations THEN
    CodeGen.EmitString('					/* LR */');
    CodeGen.EmitLn;
  END;
END LR;


(* ------------------------------------------------------------------------
 * Procedure Spill  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE Spill ( reg : Register; loc : Spilllocation );
BEGIN
  IF (reg # Regst) AND (reg # Regst1) THEN
 CodeGen.EmitString('	pushl	');  EmitRegister(reg);  CodeGen.EmitLn;
	IF EmitAnnotations THEN
 CodeGen.EmitString('					/* Spill */');  CodeGen.EmitLn;
	END;
  ELSE
	IF EmitAnnotations THEN
 CodeGen.EmitString(' 					/* Spill ');  EmitRegister(reg);  CodeGen.EmitString(' */');  CodeGen.EmitLn;
	END;
  END;
END Spill;


(* ------------------------------------------------------------------------
 * Procedure Restore  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE Restore (reg : Register; loc : Spilllocation);
BEGIN
  IF (reg # Regst) AND (reg # Regst1) THEN
 CodeGen.EmitString('	popl	');  EmitRegister(reg);  CodeGen.EmitLn;
	IF EmitAnnotations THEN
 CodeGen.EmitString('					/* Restore */');  CodeGen.EmitLn;
	END;
  ELSE
	IF EmitAnnotations THEN
 CodeGen.EmitString(' 					/* Restore ');  EmitRegister(reg);  CodeGen.EmitString(' */');  CodeGen.EmitLn;
	END;
  END;
END Restore;


(* ------------------------------------------------------------------------
 * Procedure SpillFstack  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE SpillFStack;
  VAR i : INTEGER;
BEGIN
  FOR i:=0 TO CurFStackSize - 1 DO
    DeclareTempo (FloatLong, FStackTempo[FStackStart + i]);
 CodeGen.EmitString('	fstpl	');  CodeGen.EmitInt( FStackTempo[FStackStart + i]);  CodeGen.EmitString('(%ebp)');  CodeGen.EmitLn;
    IF EmitAnnotations THEN
 CodeGen.EmitString('					/* SpillFstack */');  CodeGen.EmitLn;
    END;
  END;
  CurFStackSize := 0;
END SpillFStack;


(* ------------------------------------------------------------------------
 * Procedure PushFStack  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE PushFStack;
(* Ueberpruefung auf Floating-Point-Stack Ueberlauf *)
(* wird vor jedem push auf den 387 Stack aufgerufen *)
BEGIN
  IF CurFStackSize = 8 THEN
    (* tiefstes Stackelement als Tempo in den Speicher legen *)
    DeclareTempo (FloatLong, FStackTempo[FStackStart + 7]);
 CodeGen.EmitString('	fxch	%st(7)');  CodeGen.EmitLn;
 CodeGen.EmitString('	fstl	');  CodeGen.EmitInt( FStackTempo[FStackStart + 7]);  CodeGen.EmitString('(%ebp)');  CodeGen.EmitLn;
 CodeGen.EmitString('	fxch	%st(7)');  CodeGen.EmitLn;
 CodeGen.EmitString('	ffree	%st(7)');  CodeGen.EmitLn;
  ELSE
    INC (CurFStackSize);
  END;
  DEC (FStackStart);
  FStackTempo[FStackStart] := NoTempo;
END PushFStack;


(* ------------------------------------------------------------------------
 * Procedure PopFStack  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE PopFStack;
(* wird nach jedem pop auf den 387 Stack aufgerufen *)
BEGIN
  INC (FStackStart);
  DEC (CurFStackSize);
END PopFStack;


(* ------------------------------------------------------------------------
 * Procedure FloatOperation  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE FloatOperation (VAR op: ARRAY OF CHAR);
BEGIN
  INC (FStackStart);
  IF FStackTempo[FStackStart] # NoTempo THEN
 CodeGen.EmitTab;  CodeGen.EmitString(op);  CodeGen.EmitString('l	');  CodeGen.EmitInt( FStackTempo[FStackStart]);  CodeGen.EmitString('(%ebp)');  CodeGen.EmitLn;
    FStackTempo[FStackStart] := NoTempo;
  ELSE
 CodeGen.EmitTab;  CodeGen.EmitString( op);  CodeGen.EmitString('p	%st,%st(1)');  CodeGen.EmitLn;
    DEC (CurFStackSize);
  END;
END FloatOperation;


(* ------------------------------------------------------------------------
 * Procedure CheckRoundMode  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE CheckRoundMode (newmode: RoundMode);
BEGIN
  IF CurRoundMode <> newmode THEN
    CASE newmode OF
    | RndNearest:
 CodeGen.EmitString('	fldcw	fpucw_round_to_nearest');  CodeGen.EmitLn;
    | RndZero:
 CodeGen.EmitString('	fldcw	fpucw_round_to_zero');  CodeGen.EmitLn;
    | RndInf:
 CodeGen.EmitString('	fldcw	fpucw_round_to_inf');  CodeGen.EmitLn;
    | RndNegInf:
 CodeGen.EmitString('	fldcw	fpucw_round_to_neginf');  CodeGen.EmitLn;
    ELSE
      CompilerError ("Unknown Round Mode");
    END;
    CurRoundMode := newmode;
  END;
END CheckRoundMode;


(* ------------------------------------------------------------------------
 * Procedure CheckRoundMode2  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE CheckRoundMode2 (newmode1, newmode2: RoundMode);
BEGIN
  IF (CurRoundMode <> newmode1) AND (CurRoundMode <> newmode2) THEN
    CheckRoundMode (newmode1);
  END;
END CheckRoundMode2;


(* ------------------------------------------------------------------------
 * Function IsNilMemAdr  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE IsNilMemAdr (a: MemAdr) : BOOLEAN;
BEGIN
  RETURN (a.offset = 0) AND
	 (a.faktor = 0) AND
	 (a.base = RegNil) AND
	 (a.symbol = NullSymb)
END IsNilMemAdr;


(* ------------------------------------------------------------------------
 * Procedure EmitIndex  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitIndex (VAR base : MemAdr; index : MemAdr; reg : Register);
BEGIN
  IF NOT IsNilMemAdr (index)
   THEN base.index := reg;
 CodeGen.EmitString('	movl	');  EmitMemAdr( index);  CodeGen.EmitChar(',');  EmitRegister(reg);  CodeGen.EmitLn;
  END (* IF *);
END EmitIndex;


(* ------------------------------------------------------------------------
 * Procedure EmitRegister  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitRegister ( r : Register );
BEGIN
   CodeGen.EmitChar('%');
   IF r # Regst1
     THEN CodeGen.EmitString(IR.RegNameTable[r]);
     ELSE CodeGen.EmitString('st(1)');
   END;
END EmitRegister;


(* ------------------------------------------------------------------------
 * Procedure EmitRegister2  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitRegister2 ( r : Register; mode : CgBase.Mode );
BEGIN
  CASE SizeTable[mode] OF
  | 1: CodeGen.EmitString(ByteReg[r]);
  | 2: CodeGen.EmitString(WordReg[r]);
  | 4,8: CodeGen.EmitChar('%'); CodeGen.EmitString(IR.RegNameTable[r]);
  ELSE CompilerError ('Backend: Unknown Register Size');
  END;
END EmitRegister2;


(* ------------------------------------------------------------------------
 * Procedure EmitWordRegister(r)
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitWordRegister ( r : Register );
BEGIN
  CodeGen.EmitString(WordReg[r])
END EmitWordRegister;


(* ------------------------------------------------------------------------
 * Procedure EmitByteRegister(r)
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitByteRegister ( r : Register );
BEGIN
  CodeGen.EmitString(ByteReg[r])
END EmitByteRegister;


(* ------------------------------------------------------------------------
 * Procedure EmitPlusInt(i)
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitPlusInt ( i : LONGINT );
BEGIN
  IF i >= 0 THEN
    CodeGen.EmitString(" + ")
  ELSE
    CodeGen.EmitString(" - ")
  END;

  (* BUG: This is not going to work for i = MIN(LONGINT) -- BK, July 2018 *)
  CodeGen.EmitInt(ABS(i))
END EmitPlusInt;


(* ------------------------------------------------------------------------
 * Procedure EmitMemAdr  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitMemAdr ( am : MemAdr );
BEGIN
  WITH am DO
    IF symbol # NullSymb
      THEN CodeGen.EmitString(symbol^);
	   IF offset # 0
	     THEN EmitPlusInt (offset)
	   END;
      ELSE IF offset # 0
	     THEN CodeGen.EmitInt(offset)
	   END;
    END;
    IF (base > RegNil) OR ((index > RegNil) AND (faktor > 0))
      THEN IF (base = RegNil) AND (faktor = 1)
	     THEN base := index;
		  faktor := 0;
	   END; (* IF *)
	   CodeGen.EmitChar('(');
	   IF (base > RegNil)
	     THEN EmitRegister(base);
	   END;
	   IF (index > RegNil) AND (faktor > 0)
	     THEN CodeGen.EmitChar(',');
		  EmitRegister (index);
		  CodeGen.EmitChar(',');
		  CodeGen.EmitInt(faktor);
	   END;
	   CodeGen.EmitChar(')');
    END;
  END;
END EmitMemAdr;


(* ------------------------------------------------------------------------
 * Procedure EmitAdrMode(am)
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitAdrMode ( am : AdrMode );
BEGIN
  WITH am DO
    CASE kind OF
    | Mconst : CodeGen.EmitChar("$"); CodeGen.EmitInt(constant);
    | Mreg   : EmitRegister2(reg, mode);
    | Mmem   : EmitMemAdr(mem)
    END (* CASE *)
  END (* WITH *)
END EmitAdrMode;


(* ------------------------------------------------------------------------
 * Procedure EmitSuffix(s)
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitSuffix ( s : CgBase.Mode );
BEGIN
  CodeGen.EmitChar(SuffixTable[s])
END EmitSuffix;


(* ------------------------------------------------------------------------
 * Procedure EmitSigned(s)
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitSigned ( s : CgBase.Mode );
BEGIN
  IF SignedTable[s] THEN
    CodeGen.EmitChar("s")
  ELSE
    CodeGen.EmitChar("z")
  END (* IF *)
END EmitSigned;


(* ------------------------------------------------------------------------
 * Procedure DeclareModule(extern, compUnitName, ref)
 * ------------------------------------------------------------------------
 * Creates a new module entry for compilation unit 'compUnitName'.
 * ------------------------------------------------------------------------ *)

PROCEDURE DeclareModule
  (     extern       : BOOLEAN;
    VAR compUnitName : ARRAY OF CHAR;
    VAR ref          : CgBase.ModuleIndex);

VAR
  str : String;

BEGIN
  NEW(ref);
  WITH ref^ DO
    Extern := extern;
    IF Enabled(ElfOption) THEN
      Name := MakeRelSymb(compUnitName);
      StringAssign(str, compUnitName);
      StringAppend1(str, "_s");
    ELSE
      StringAssign(str, "_");
      StringAppend1(str, compUnitName);
      Name := MakeRelSymb(str);
      StringAppend1(str, "_s");
    END; (* IF *)
    Statics := MakeRelSymb(str)
  END (* WITH *)
END DeclareModule;


(* ------------------------------------------------------------------------
 * Procedure EmitProcDecl
 *  (extern, isFunction, procMode, procName, num, module, lvl, parent, ref)
 * ------------------------------------------------------------------------
 * Creates a new procedure entry for procedure 'procName' and emits a
 * corresponding label declaration.
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitProcDecl
  (     extern,
        isFunction   : BOOLEAN;
        procMode     : CgBase.Mode;
    VAR procName     : ARRAY OF CHAR;
        procNumber   : SHORTCARD;
        module       : CgBase.ModuleIndex;
        level        : SHORTCARD;
        parent       : CgBase.ProcIndex;
    VAR ref          : CgBase.ProcIndex);

(* Replacement for DeclareProcedure *)

CONST
  MaxLen = 80;

VAR
  prefix : CHAR;
  len : CARDINAL;
  label, procNumStr : String;
  qualifier, ident : POINTER TO String;

BEGIN
  NEW(ref);
  ref^.Extern := extern;
  ref^.IsFunction : isFunction;
  ref^.Name := MakeRelSymb(procName);
  ref^.Number := procNumber;
  ref^.Module := module;
  ref^.Level := level;
  ref^.Father := parent;
  ref^.Entry := NIL;

  (* generate procedure's assembly label *)

  (* prefix *)
  IF (* ELF *) MockaOptions.isEnabled(MockaOptions.Elf) THEN
    prefix := NUL;
    len := 0

  ELSE (* MachO *)
    prefix := "_";
    len := 1
  END; (* IF *)

  IF (* Modula-2 procedure *) procNumber # CprocNumber THEN

    (* qualifier *)
    IF (* global procedure *) level = 0 THEN

      (* use module name *)
      qualifier := module^.Name^

    ELSE (* local procedure *)

      (* use parent's label, which would already have a prefix, if any *)
      qualifier := parent^.Entry^;
      prefix := "";
      len = 0
    END; (* If *)

    (* ident *)
    ident := procName;

    (* label length *)
    len := len + StringLength(qualifier^) + StringLength(ident^) + 1;

    (* permitted length *)
    IF len <= MaxLen THEN
      ComposeProcLabel(label, prefix, qualifier^, ident^)

    ELSE (* excess length *)
      (* use module name and proc name ... *)
      ComposeProcLabel(label, prefix, module^.Name^, ident^);
      (* ... and append procedure index number to avoid name collision *)
      ConvertLONGINTtoString(procNumber, procNumStr);
      (* use double lowline separator, it cannot occur in M2 identifiers *)
      StringAppend2(label, "__", procNumStr)
    END (* IF *)

  ELSE (* foreign procedure *)

    (* no qualifier *)
    ComposeProcLabel(label, prefix, "", procName)
  END; (* IF *)

  (* create new symbol entry for label *)

  ref^.Entry := MakeRelSymb(label);

  (* emit label declaration *)

  (* global directive *)
  CodeGen.EmitTab;
  CodeGen.EmitString(".globl");

  (* label *)
  CodeGen.EmitTab;
  CodeGen.EmitString(ref^.Entry^);

  (* eol *)
  CodeGen.EmitLn
END EmitProcDecl;

(* ------------------------------------------------------------------------
 * Obsolete procedure DeclareProcedure -- replaced by EmitProcDecl
 * ------------------------------------------------------------------------ *)

PROCEDURE DeclareProcedure
  (     extern,
        isFunction   : BOOLEAN;
        procMode     : CgBase.Mode;
    VAR procName     : ARRAY OF CHAR;
        procNumber   : SHORTCARD;
        module       : CgBase.ModuleIndex;
        level        : SHORTCARD;
        parent       : CgBase.ProcIndex;
    VAR ref          : CgBase.ProcIndex);

BEGIN
  WITH ref^ DO
    Extern := extern;
    IsFunction := isFunction;
    Name := MakeRelSymb(procName);
    Number := procNumber;
    Module := module;
    Level := level;
    Father := parent
  END; (* WITH *)

  IF ProcNumber # CprocNumber THEN
    IF level = 0 THEN
      StringAssign(t, module^.Name^)
    ELSE
      StringAssign(t, father^.Entry^)
    END; (* IF *)

    IF StringLength(t)+1+StringLength(ProcName) >= 80 THEN
      (* Produce Name and Number   *)
      ConvertLONGINTtoString(ProcNumber, s);
      StringAssign(t, module^.Name^);
      StringAppend1(t, '_');
      StringAppend1(t, ProcName);
      StringAppend1(t, '_');
      StringAppend1(t, s);
    ELSE (* less than 80 chars *)
      IF ProcNumber # CompUnitProcNumber THEN
        StringAppend2(t, '_', ProcName);
      END (* IF *)
    END; (* IF *)

    (*ref^.Entry*) Entry := MakeRelSymb (t);

  ELSE (* ProcNumber = CprocNumber *)
    IF Enabled (ElfOption) THEN
      (*ref^.Entry*) Entry := MakeRelSymb (ProcName);
    ELSE
      StringConcat2 (t,'_',ProcName);
      (*ref^.Entry*) Entry := MakeRelSymb (t);
    END (* IF *)
  END; (* IF *)

  CodeGen.EmitString('	.globl	');
  CodeGen.EmitString((*ref^.Entry*) Entry^);
  CodeGen.EmitLn
END DeclareProcedure;


(* ------------------------------------------------------------------------
 * Procedure ComposeProcLabel (label, prefix, qualifier, ident)
 * ------------------------------------------------------------------------
 * Composes a  procedure label  by concatenating 'prefix',  'qualifier' and
 * 'ident'.  Passes the result back  in 'label'.   An  input parameter  for
 * which NUL is passed in will be ignored.  An input parameter whose length
 * exceeds 39 characters is cut off, any excess characters will be ignored.
 * A lowline ("_") is inserted between 'qualifier' and 'ident', if and only
 * if both are non-empty.  The maximum label length is thus  80 characters.
 * If the  capacity  of out-parameter 'label' is  insufficient  to hold the
 * concatenation result and its NUL terminator,  the  operation is  aborted
 * and an empty string is passed back in 'label'.
 * ------------------------------------------------------------------------ *)

PROCEDURE ComposeProcLabel
  ( VAR label   : ARRAY OF CHAR;
        prefix  : CHAR;
        qualifier,
        ident   : ARRAY OF CHAR );

CONST
  (* the shortest possible label is an unqualified single letter identifier
     which requires a capacity of two characters, including NUL terminator. *)
  MinLabelCapacity = 2;

  (* significant length of qualifiers and identifiers *)
  SignificantChars = 39;

VAR
  ch : CHAR;
  sourceIndex, maxSourceIndex, targetIndex, targetCapacity : CARDINAL;

BEGIN
  targetCapacity := HIGH(label);

  (* if label capacity is below minimum, pass empty string and exit *)
  IF targetCapacity < MinLabelCapacity THEN
    label[0] := NUL;
    RETURN
  END; (* IF *)

  targetIndex := 0;

  (* copy prefix to label *)
  IF prefix # NUL THEN
    label[targetIndex] := prefix;
    INC(targetIndex]
  END; (* IF *)

  (* copy qualifier to label *)
  IF qualifier[0] # NUL THEN

    sourceIndex := 0;
    IF HIGH(qualifier) > SignificantChars THEN
      maxSourceIndex := SignificantChars
    ELSE
      maxSourceIndex := HIGH(qualifier)
    END; (* IF *)

    WHILE sourceIndex <= maxSourceIndex DO

      (* if no space left for terminator, pass empty string and exit *)
      IF targetIndex >= targetCapacity THEN
        label[0] := NUL;
        RETURN
      END; (* IF *)

      (* get char from source *)
      ch := qualifier[sourceIndex];

      (* NUL terminates source *)
      IF ch = NUL THEN
        EXIT
      END; (* IF *)

      (* copy char to target *)
      label[targetIndex] := ch;

      (* move to next char *)
      INC(sourceIndex);
      INC(targetIndex)
    END (* WHILE *)
  END; (* IF *)

  (* copy ident to label *)
  IF ident[0] # NUL THEN

    (* if qualifier present, append lowline to label *)
    IF qualifier[0] # NUL THEN
      label[targetIndex] := "_";
      INC(targetIndex)
    END; (* IF *)

    sourceIndex := 0;
    IF HIGH(ident) > SignificantChars THEN
      maxSourceIndex := SignificantChars
    ELSE
      maxSourceIndex := HIGH(ident)
    END; (* IF *)

    WHILE sourceIndex <= maxSourceIndex DO

      (* if no space left for terminator, pass empty string and exit *)
      IF targetIndex >= targetCapacity THEN
        label[0] := NUL;
        RETURN
      END; (* IF *)

      (* get char from source *)
      ch := ident[sourceIndex];

      (* NUL terminates source *)
      IF ch = NUL THEN
        EXIT
      END; (* IF *)

      (* copy char to target *)
      label[targetIndex] := ch;

      (* move to next char *)
      INC(sourceIndex);
      INC(targetIndex)
    END (* WHILE *)
  END; (* IF *)

  (* terminate label *)
  label[targetIndex] := NUL;
  RETURN
END ComposeProcLabel;


(* ------------------------------------------------------------------------
 * Procedure DeclareString  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE DeclareString
   (    length : SHORTCARD;
    VAR string : ARRAY OF CHAR;
    VAR ref    : CgBase.StringIndex);
  VAR l   : CARDINAL;
      c   : CHAR;
      numbersNeedRestart: BOOLEAN;
BEGIN
   numbersNeedRestart:=FALSE;
   GetLabel (ref);
 CodeGen.EmitString('	.data');  CodeGen.EmitLn;
 CodeGen.EmitString( ref^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
 CodeGen.EmitString(' 	.ascii	"');
   FOR l := 0 TO length - 1 DO
      c := string[l];
      IF numbersNeedRestart AND ('0'<=c) AND (c<='9') THEN	(* Restart *)
 CodeGen.EmitString('"');  CodeGen.EmitLn;
 CodeGen.EmitString('	.ascii	"');
      END;
      IF (' ' <= c) AND (c <= 'z') AND (c # 42C) AND (c # '\') THEN
	 CodeGen.EmitChar(c);
         numbersNeedRestart:=FALSE;
      ELSE
	 IF l < length - 1 THEN
	    CodeGen.EmitChar('\');
 CodeGen.EmitInt( ORD (c) DIV 64);  CodeGen.EmitInt( (ORD (c) MOD 64) DIV 8);  CodeGen.EmitInt( ORD (c) MOD 8);
	 END;
         numbersNeedRestart:=TRUE;
      END;
   END;
   CodeGen.EmitString('\000"'); CodeGen.EmitLn;
 CodeGen.EmitString('	.text');  CodeGen.EmitLn;
END DeclareString;


(* ------------------------------------------------------------------------
 * Procedure DeclareTempo  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE DeclareTempo (mode: CgBase.Mode; VAR tempo: CgBase.Tempo);
BEGIN
  IF mode = FloatLong
    THEN INC(CurFrameSize, 8);
    ELSE INC(CurFrameSize, 4);
  END;
  tempo := -CurFrameSize;
END DeclareTempo;


(* ------------------------------------------------------------------------
 * Procedure DeclareTransferTempo  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE DeclareTransferTempo;
BEGIN
  IF TransferTempo = NoTempo
    THEN DeclareTempo (FloatShort, TransferTempo);
  END;
END DeclareTransferTempo;


(* ------------------------------------------------------------------------
 * Procedure BeginModule  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE BeginModule
   (AtModulName  :  ARRAY OF CHAR;
    AtFrameSize  :  LONGINT);
BEGIN
   CallLevel := 0;
   CurPos.line := 0;
   CurPos.col := 0;

   DisplaySym := MakeRelSymb ('DISPLAY_');

   FOR i := 0 TO MaxDisplay DO SaveDisplay [i] := FALSE; END;

   IR.OptEmitIR		:= Enabled (oEmitIR);
   IR.OptEmitMatch	:= Enabled (oEmitMatch);
   IR.OptRegAlloc	:= Enabled (oRegAlloc);

   BuildLibraryFileName (AtModulName,
			 KindAssemblerSourceFile, AsmListFileName);
   CodeGen.Open (AsmListFileName);
   StringAssign (ModName, AtModulName);

   InitCgBase;

   IF AtFrameSize > 0 THEN
     CodeGen.EmitString('	.comm ');
     IF NOT Enabled(ElfOption) THEN
       CodeGen.EmitChar('_')
     END;
     CodeGen.EmitString( AtModulName);
     CodeGen.EmitString('_s, ');
     CodeGen.EmitInt( 4 * ((ABS(AtFrameSize)+3) DIV 4)); CodeGen.EmitLn;
   END;
 CodeGen.EmitString('	.text'); CodeGen.EmitLn;
END BeginModule;


(*------ end   insertion IpEmit_i ------*)

VAR
  ai : CARDINAL;
  localavail : RegisterSet;

(******* empty insertion IpEmit *******)


(* ------------------------------------------------------------------------
 * Non-Terminal attribute type
 * ------------------------------------------------------------------------ *)

TYPE NtAttributes = RECORD
  CASE  : IR.NonTerminal OF
  | ntreg : reg :
    RECORD (*empty*) END

  | ntfreg : freg :
    RECORD (*empty*) END

  | ntfstack : fstack :
    RECORD (*empty*) END

  | ntConstant : Constant :
    RECORD (*empty*) END

  | ntFloatConstant : FloatConstant :
    RECORD (*empty*) END

  | ntSimpleVariable : SimpleVariable :
    RECORD (*empty*) END

  | ntSymPlusOffset : SymPlusOffset :
    RECORD
      symbol : CgBase.RelSymb;
    END (* RECORD *)

  | ntRegPlusSymPlusOffset : RegPlusSymPlusOffset :
    RECORD
      base : Register;
      symbol : CgBase.RelSymb
    END (* RECORD *)

  | ntOffsetPlusIndexMultFaktor : OffsetPlusIndexMultFaktor :
    RECORD
      index : Register
    END (* RECORD *)

  | ntmem : mem :
    RECORD
      am : MemAdr
    END (* RECORD *)

  | ntCMem : CMem :
    RECORD
      am : MemAdr
    END (* RECORD *)

  | ntRegOrIm : RegOrIm :
    RECORD
      am : AdrMode
    END (* RECORD *)

  | ntRegOrCMem : RegOrCMem :
    RECORD
      am : AdrMode
    END (* RECORD *)

  | ntRegOrCMemOrIm : RegOrCMemOrIm :
    RECORD
      am : AdrMode
    END (* RECORD *)

  | ntarglist : arglist :
    RECORD (*empty*) END

  | ntloadln2 : loadln2 :
    RECORD (*empty*) END
  END (* CASE *)
END; (* NtAttributes *)


(* ------------------------------------------------------------------------
 * Procedure PerformActions  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE PerformActions (ai : RegAlloc.AllocIndex);
VAR i : CARDINAL;
BEGIN
   WITH RegAlloc.allocation [ai] DO
      FOR i:=1 TO num DO
	 WITH a[i] DO
	    IF action=aLr THEN
             LR (regto, regfrom);
    IF IR.OptEmitMatch THEN
                WriteString (' Copy Register ');
                PrintRegister (regfrom);
                WriteString (' into ');
                PrintRegister (regto);
                WriteLn;
    END;
	    ELSE
	       Restore (reg, spilllocation);
    IF IR.OptEmitMatch THEN
                WriteString (' Restore Register ');
                PrintRegister (reg);
                WriteString (' from ');
                WriteInt (spilllocation,1);
                WriteLn;
    END;
         END;
	 END;
     END;
  END;
END PerformActions;


(* ------------------------------------------------------------------------
 * Procedure WriteNest
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteNest ( i : INTEGER );

VAR
  j : INTEGER;

BEGIN
  FOR j := 1 TO i DO
    WriteString (".  ")
  END (* FOR *)
END WriteNest;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrreg  --  does nothing
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrreg ( at: NtAttributes );
BEGIN
  (*empty*)
END WriteAttrreg;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrfreg  --  does nothing
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrfreg ( at: NtAttributes );
BEGIN
  (*empty*)
END WriteAttrfreg;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrfstack  --  does nothing
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrfstack ( at: NtAttributes );
BEGIN
  (*empty*)
END WriteAttrfstack;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrConstant  --  does nothing
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrConstant ( at: NtAttributes );
BEGIN
  (*empty*)
END WriteAttrConstant;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrFloatConstant  --  does nothing
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrFloatConstant ( at: NtAttributes );
BEGIN
  (*empty*)
END WriteAttrFloatConstant;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrFloatConstant  --  does nothing
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrSimpleVariable ( at: NtAttributes );
BEGIN
  (*empty*)
END WriteAttrSimpleVariable;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrSymPlusOffset  --  needs reformatting
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrSymPlusOffset ( at: NtAttributes );
BEGIN
       WriteString ('symbol=');
       PrintRelSymb ( at.SymPlusOffset.symbol );
       Write (' ');
END WriteAttrSymPlusOffset;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrRegPlusSymPlusOffset  --  needs reformatting
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrRegPlusSymPlusOffset (at: NtAttributes);
BEGIN
       WriteString ('base=');
       PrintRegister ( at.RegPlusSymPlusOffset.base );
       Write (' ');
       WriteString ('symbol=');
       PrintRelSymb ( at.RegPlusSymPlusOffset.symbol );
       Write (' ');
END WriteAttrRegPlusSymPlusOffset;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrOffsetPlusIndexMultFaktor  --  needs reformatting
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrOffsetPlusIndexMultFaktor (at: NtAttributes);
BEGIN
       WriteString ('index=');
       PrintRegister ( at.OffsetPlusIndexMultFaktor.index );
       Write (' ');
END WriteAttrOffsetPlusIndexMultFaktor;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrmem  --  needs reformatting
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrmem ( at: NtAttributes );
BEGIN
       WriteString ('am=');
       PrintMemAdr ( at.mem.am );
       Write (' ');
END WriteAttrmem;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrCMem  --  needs reformatting
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrCMem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintMemAdr ( at.CMem.am );
       Write (' ');
END WriteAttrCMem;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrRegOrIm  --  needs reformatting
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrRegOrIm (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrIm.am );
       Write (' ');
END WriteAttrRegOrIm;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrRegOrCMem  --  needs reformatting
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrRegOrCMem (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrCMem.am );
       Write (' ');
END WriteAttrRegOrCMem;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrRegOrCMemOrIm  --  needs reformatting
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrRegOrCMemOrIm (at: NtAttributes);
BEGIN
       WriteString ('am=');
       PrintAdrMode ( at.RegOrCMemOrIm.am );
       Write (' ');
END WriteAttrRegOrCMemOrIm;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrarglist  --  does nothing
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrarglist ( at: NtAttributes );
BEGIN
  (*empty*)
END WriteAttrarglist;


(* ------------------------------------------------------------------------
 * Procedure WriteAttrloadln2  --  does nothing
 * ------------------------------------------------------------------------ *)

PROCEDURE WriteAttrloadln2 (at: NtAttributes);
BEGIN
  (*empty*)
END WriteAttrloadln2;


(* ------------------------------------------------------------------------
 * Procedure EmitNtreg  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtreg
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
  AT1   :  NtAttributes;
  AT2   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntreg] OF
  | 70 :
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 70/2807 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	subl	$4,%esp');  CodeGen.EmitLn;
	CheckRoundMode (RndZero);
 CodeGen.EmitString('	fistpl	(%esp)');  CodeGen.EmitLn;
 CodeGen.EmitString('	popl	');  EmitRegister(RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;
	PopFStack;

   | 71 :
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 71/2763 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	subl	$4,%esp');  CodeGen.EmitLn;
	CheckRoundMode (RndNegInf);
 CodeGen.EmitString('	fistpl	(%esp)');  CodeGen.EmitLn;
 CodeGen.EmitString('	popl	');  EmitRegister(RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;
	PopFStack;

   | 72 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 72/2522 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	call	');  CodeGen.EmitString( e^.son[2]^.attr^.ProcedureConstant.index^.Entry^);  CodeGen.EmitLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 CodeGen.EmitString('	addl	$');  CodeGen.EmitInt( e^.attr^.FunctionCall.paramsize);  CodeGen.EmitString(', %esp');  CodeGen.EmitLn;
	END;

   | 73 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 73/2507 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FunctionCall ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	call	');  EmitRegister(RegAlloc.allocation[ai].op[2]);  CodeGen.EmitLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 CodeGen.EmitString('	addl	$');  CodeGen.EmitInt( e^.attr^.FunctionCall.paramsize);  CodeGen.EmitString(', %esp');  CodeGen.EmitLn;
	END;

   | 74 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 74/2158 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' TestOdd ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	and');  EmitSuffix( e^.attr^.TestOdd.mode);  CodeGen.EmitString('	$1,');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.TestOdd.mode);  CodeGen.EmitLn;
	IF NOT e^.attr^.TestOdd.cond THEN
 CodeGen.EmitString('	xor');  EmitSuffix( e^.attr^.TestOdd.mode);  CodeGen.EmitString('	$1,');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.TestOdd.mode);  CodeGen.EmitLn;
	END;

   | 75 :
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 75/2146 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' TestMembershipL ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	btl	');  EmitAdrMode( AT0.RegOrIm.am);  CodeGen.EmitChar(',');  EmitAdrMode( AT1.RegOrCMem.am);  CodeGen.EmitLn;
	IF e^.attr^.TestMembershipL.cond THEN
 CodeGen.EmitString('	setb	');  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;
	ELSE
 CodeGen.EmitString('	setnb	');  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;
	END;

   | 76 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 76/2114 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetCompare ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	movl	');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitLn;
	CASE e^.attr^.SetCompare.rel OF
	| RelLess:
 CodeGen.EmitString('	or	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitLn;
	e^.attr^.SetCompare.rel := RelUnequal;
	| RelLessOrEqual:
 CodeGen.EmitString('	and	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitLn;
	e^.attr^.SetCompare.rel := RelEqual;
	| RelGreater:
 CodeGen.EmitString('	and	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitLn;
	e^.attr^.SetCompare.rel := RelUnequal;
	| RelGreaterOrEqual:
 CodeGen.EmitString('	or	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitLn;
	e^.attr^.SetCompare.rel := RelEqual;
	END;
 CodeGen.EmitString('	cmpl	');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	set');  CodeGen.EmitString( RelationTable[e^.attr^.SetCompare.rel][FALSE]);  CodeGen.EmitTab;  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;

   | 77 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 77/2105 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetCompare ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	cmpl	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	set');  CodeGen.EmitString( RelationTable[e^.attr^.SetCompare.rel][FALSE]);  CodeGen.EmitTab;  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;

   | 78 :
  EmitNtfstack(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 78/2087 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	INC (FStackStart);
	IF FStackTempo[FStackStart] # NoTempo THEN
 CodeGen.EmitString('	fcompl	');  CodeGen.EmitInt( FStackTempo[FStackStart]);  CodeGen.EmitString('(%ebp)');  CodeGen.EmitLn;
	  DEC (CurFStackSize);
	ELSE
 CodeGen.EmitString('	fcompp');  CodeGen.EmitLn;
	  DEC (CurFStackSize, 2);
	END;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	set');  CodeGen.EmitString( RelationTable[Reverse[e^.attr^.FloatCompare.rel]][SignedTable[e^.attr^.FloatCompare.mode]]);  CodeGen.EmitTab;  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;

   | 79 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 79/2075 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	fcomp');  EmitSuffix( e^.son[1]^.gcg^.CMem.mode);  CodeGen.EmitTab;  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	set');  CodeGen.EmitString( RelationTable[Reverse[e^.attr^.FloatCompare.rel]][SignedTable[e^.attr^.FloatCompare.mode]]);  CodeGen.EmitTab;  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;
	PopFStack;

   | 80 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 80/2063 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FloatCompare ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	fcomp');  EmitSuffix( e^.son[2]^.gcg^.CMem.mode);  CodeGen.EmitTab;  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	set');  CodeGen.EmitString( RelationTable[e^.attr^.FloatCompare.rel][SignedTable[e^.attr^.FloatCompare.mode]]);  CodeGen.EmitTab;  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;
	PopFStack;

   | 81 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 81/2055 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.FixedCompare.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( e^.son[1]^.gcg^.Constant.val);  CodeGen.EmitChar(',');  EmitAdrMode( AT1.RegOrCMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	set');  CodeGen.EmitString( RelationTable[Reverse[e^.attr^.FixedCompare.rel]][SignedTable[e^.attr^.FixedCompare.mode]]);  CodeGen.EmitTab;  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;

   | 82 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 82/2047 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.FixedCompare.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	set');  CodeGen.EmitString( RelationTable[e^.attr^.FixedCompare.rel][SignedTable[e^.attr^.FixedCompare.mode]]);  CodeGen.EmitTab;  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;

   | 83 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 83/2039 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedCompare ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.FixedCompare.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedCompare.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	set');  CodeGen.EmitString( RelationTable[e^.attr^.FixedCompare.rel][SignedTable[e^.attr^.FixedCompare.mode]]);  CodeGen.EmitTab;  EmitByteRegister ( RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;

   | 84 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
  EmitNtRegOrCMemOrIm(e^.son[3],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 84/1987 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	GetLabel(lab);
	GetLabel(lab2);
	IF e^.attr^.CheckL.CheckLwb THEN
 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.CheckL.LwbMode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.CheckL.LwbMode);  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[RelLess][SignedTable[e^.attr^.CheckL.LwbMode]]);  CodeGen.EmitTab;  CodeGen.EmitString( lab2^);  CodeGen.EmitLn;
	END;
	IF e^.attr^.CheckL.CheckUpb THEN
 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.CheckL.UpbMode);  CodeGen.EmitTab;  EmitAdrMode( AT2.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.CheckL.UpbMode);  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[RelLessOrEqual][SignedTable[e^.attr^.CheckL.UpbMode]]);  CodeGen.EmitTab;  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
	ELSE
 CodeGen.EmitString('	jmp	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
	END;
 CodeGen.EmitString( lab2^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
 CodeGen.EmitString('   	call	BoundErr_		');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;

   | 85 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
  EmitNtRegOrCMemOrIm(e^.son[3],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 85/1974 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	push');  EmitSuffix( e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitTab;  EmitAdrMode( AT2.RegOrCMemOrIm.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	push');  EmitSuffix( e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	bound');  EmitSuffix( e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitString(',(%esp)');  CodeGen.EmitLn;
 CodeGen.EmitString('	addl	$');  CodeGen.EmitInt( 2*SizeTable[e^.son[1]^.gcg^.reg.mode]);  CodeGen.EmitString(',%esp');  CodeGen.EmitLn;

   | 86 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
  EmitNtConstant(e^.son[3],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 86/1946 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	GetLabel(lab);
 CodeGen.EmitString('	.data');  CodeGen.EmitLn;
	CASE SizeTable[e^.son[1]^.gcg^.reg.mode] OF
	| 4:
 CodeGen.EmitString('	.align 4');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
 CodeGen.EmitString('	.long	');  CodeGen.EmitInt( e^.son[2]^.gcg^.Constant.val);  CodeGen.EmitChar(',');  CodeGen.EmitInt( e^.son[3]^.gcg^.Constant.val);  CodeGen.EmitLn;
	| 2:
 CodeGen.EmitString('	.align 2');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
 CodeGen.EmitString('	.word	');  CodeGen.EmitInt( e^.son[2]^.gcg^.Constant.val);  CodeGen.EmitChar(',');  CodeGen.EmitInt( e^.son[3]^.gcg^.Constant.val);  CodeGen.EmitLn;
	END;
 CodeGen.EmitString('	.text');  CodeGen.EmitLn;
 CodeGen.EmitString('	bound');  EmitSuffix( e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitChar(',');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;

   | 87 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
  EmitNtConstant(e^.son[3],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 87/1941 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' CheckL ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 88 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 88/1881 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Coerce ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 89 :
  EmitNtRegOrCMem(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 89/1868 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Coerce ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	IF SignedTable[e^.attr^.Coerce.premode] AND SignedTable[e^.attr^.Coerce.postmode] THEN
 CodeGen.EmitString('	movs');  EmitSuffix( e^.son[1]^.gcg^.RegOrCMem.mode);  EmitSuffix( e^.attr^.Coerce.postmode);  CodeGen.EmitTab;  EmitAdrMode( AT0.RegOrCMem.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.Coerce.postmode);  CodeGen.EmitLn;
	ELSE
 CodeGen.EmitString('	movz');  EmitSuffix( e^.son[1]^.gcg^.RegOrCMem.mode);  EmitSuffix( e^.attr^.Coerce.postmode);  CodeGen.EmitTab;  EmitAdrMode( AT0.RegOrCMem.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.Coerce.postmode);  CodeGen.EmitLn;
	END;

   | 90 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 90/1785 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Trunc ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	GetLabel(lab);
 CodeGen.EmitString('	fcoml	TwoExp31_');  CodeGen.EmitLn;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	jb	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
 CodeGen.EmitString('	fsubl	TwoExp32_');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
 CodeGen.EmitString('	subl	$4,%esp');  CodeGen.EmitLn;
	CheckRoundMode2 (RndZero, RndNegInf);
 CodeGen.EmitString('	fistpl	(%esp)');  CodeGen.EmitLn;
 CodeGen.EmitString('	popl	');  EmitRegister(RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;
	PopFStack;

   | 91 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 91/1735 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' Cap ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 GetLabel(lab);
 CodeGen.EmitString('	cmpb	$');  CodeGen.EmitInt( ORD('a'));  CodeGen.EmitChar(',');  EmitByteRegister ( RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	jl	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
 CodeGen.EmitString('	cmpb	$');  CodeGen.EmitInt( ORD('z'));  CodeGen.EmitChar(',');  EmitByteRegister ( RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	jg	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
 CodeGen.EmitString('	subb	$');  CodeGen.EmitInt( ORD('a') - ORD('A'));  CodeGen.EmitChar(',');  EmitByteRegister ( RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;

   | 92 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
  EmitNtreg(e^.son[3],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 92/1713 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusRange ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 GetLabel(lab);
 CodeGen.EmitString(' 	sub');  EmitSuffix( e^.attr^.SetPlusRange.LwbMode);  CodeGen.EmitString(' 	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( Regecx,e^.attr^.SetPlusRange.LwbMode);  CodeGen.EmitLn;
 CodeGen.EmitString(' 	jl	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
 CodeGen.EmitString('	incb	%cl');  CodeGen.EmitLn;
 CodeGen.EmitString('	movl	$-1,');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	shll	%cl,');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	notl	');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	mov');  EmitSuffix( e^.attr^.SetPlusRange.LwbMode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( Regecx,e^.attr^.SetPlusRange.LwbMode);  CodeGen.EmitLn;
 CodeGen.EmitString('	shll	%cl,');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	orl	');  EmitRegister(RegAlloc.allocation[ai].scr[1]);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;

   | 93 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
  EmitNtConstant(e^.son[3],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 93/1707 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusRange ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	orl	$');  CodeGen.EmitInt( PowerTable[e^.son[3]^.gcg^.Constant.val+1]-PowerTable[e^.son[2]^.gcg^.Constant.val]);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 94 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 94/1701 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusSingleL ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	btsl	');  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 95 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 95/1695 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetPlusSingleL ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	orl	$');  CodeGen.EmitInt( PowerTable[e^.son[2]^.gcg^.Constant.val]);  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 96 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 96/1672 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetSymDifference ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	xorl	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 97 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 97/1672 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetSymDifference ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	xorl	');  EmitAdrMode( AT0.RegOrCMemOrIm.am);  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[2]);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 98 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 98/1653 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetIntersection ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	andl	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 99 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 99/1653 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetIntersection ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	andl	');  EmitAdrMode( AT0.RegOrCMemOrIm.am);  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[2]);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 100 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 100/1618 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetDifference ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString(' 	andl	$');  CodeGen.EmitInt( INTEGER(BITSET(-1) - BITSET(e^.son[2]^.gcg^.Constant.val)));  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;

   | 101 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 101/1609 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetDifference ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	notl	');  EmitRegister(RegAlloc.allocation[ai].op[2]);  CodeGen.EmitLn;
 CodeGen.EmitString(' 	andl	');  EmitAdrMode( AT0.RegOrCMemOrIm.am);  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[2]);  CodeGen.EmitLn;

   | 102 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 102/1590 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetUnion ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	orl	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 103 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 103/1590 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' SetUnion ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	orl	');  EmitAdrMode( AT0.RegOrCMemOrIm.am);  CodeGen.EmitString(', ');  EmitRegister(RegAlloc.allocation[ai].op[2]);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 104 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 104/1503 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	cwd');  CodeGen.EmitLn;
 CodeGen.EmitString('	idiv');  EmitSuffix( e^.attr^.FixedMod.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode);  CodeGen.EmitLn;

   | 105 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 105/1492 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	xor');  EmitSuffix( e^.attr^.FixedMod.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMod.mode);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMod.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	div');  EmitSuffix( e^.attr^.FixedMod.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode);  CodeGen.EmitLn;

   | 106 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 106/1481 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	cdq');  CodeGen.EmitLn;
 CodeGen.EmitString('	idiv');  EmitSuffix( e^.attr^.FixedMod.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMod.mode);  CodeGen.EmitLn;

   | 107 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 107/1460 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMod ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	and');  EmitSuffix( e^.attr^.FixedMod.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( e^.son[2]^.gcg^.Constant.val-1);  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMod.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 108 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 108/1443 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	cwd');  CodeGen.EmitLn;
 CodeGen.EmitString('	idiv');  EmitSuffix( e^.attr^.FixedDiv.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode);  CodeGen.EmitLn;

   | 109 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 109/1431 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	xor');  EmitSuffix( e^.attr^.FixedDiv.mode);  CodeGen.EmitTab;  EmitRegister2 ( Regedx,e^.attr^.FixedDiv.mode);  CodeGen.EmitChar(',');  EmitRegister2 ( Regedx,e^.attr^.FixedDiv.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	div');  EmitSuffix( e^.attr^.FixedDiv.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode);  CodeGen.EmitLn;

   | 110 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 110/1419 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	cdq');  CodeGen.EmitLn;
 CodeGen.EmitString('	idiv');  EmitSuffix( e^.attr^.FixedDiv.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedDiv.mode);  CodeGen.EmitLn;

   | 111 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 111/1388 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	sar');  EmitSuffix( e^.attr^.FixedDiv.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2 (e^.son[2]^.gcg^.Constant.val));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedDiv.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 112 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 112/1365 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	shr');  EmitSuffix( e^.attr^.FixedDiv.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2 (e^.son[2]^.gcg^.Constant.val));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedDiv.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 113 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 113/1349 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 114 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 114/1343 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedDiv ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 115 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 115/1317 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	mul');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 116 :
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 116/1287 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

EmitIndex (e^.son[1]^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[ai].reg);
 CodeGen.EmitString('	mov');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitMemAdr( e^.son[1]^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	imul');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode);  CodeGen.EmitLn;

   | 117 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 117/1281 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	imul');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( e^.son[1]^.gcg^.Constant.val);  CodeGen.EmitChar(',');  EmitAdrMode( AT1.RegOrCMem.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 118 :
  EmitNtRegOrCMem(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 118/1281 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	imul');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( e^.son[2]^.gcg^.Constant.val);  CodeGen.EmitChar(',');  EmitAdrMode( AT0.RegOrCMem.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.attr^.FixedMult.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 119 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 119/1274 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	imul');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 120 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 120/1274 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	imul');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitAdrMode( AT0.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 121 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 121/1206 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[2]^.gcg^.Constant.val));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 122 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 122/1206 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[1]^.gcg^.Constant.val));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 123 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 123/1160 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	add');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	add');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;

   | 124 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 124/1160 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	add');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	add');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;

   | 125 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 125/1153 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	add');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 126 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 126/1153 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	add');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 127 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 127/1140 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 128 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 128/1140 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMult ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 129 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 129/1090 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedMinus ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	sub');  EmitSuffix( e^.son[2]^.gcg^.RegOrCMemOrIm.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[2]^.gcg^.RegOrCMemOrIm.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 130 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 130/993 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedPlus ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	add');  EmitSuffix( e^.son[2]^.gcg^.RegOrCMemOrIm.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[2]^.gcg^.RegOrCMemOrIm.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 131 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 131/993 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedPlus ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString(' 	add');  EmitSuffix( e^.son[1]^.gcg^.RegOrCMemOrIm.mode);  CodeGen.EmitTab;  EmitAdrMode( AT0.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.son[1]^.gcg^.RegOrCMemOrIm.mode);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 132 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 132/922 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedAbs ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	GetLabel (lab);
 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.FixedAbs.mode);  CodeGen.EmitString('	$0,');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedAbs.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	jg	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
 CodeGen.EmitString('	neg');  EmitSuffix( e^.attr^.FixedAbs.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedAbs.mode);  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;

   | 133 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 133/902 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FixedNegate ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	neg');  EmitSuffix( e^.attr^.FixedNegate.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedNegate.mode);  CodeGen.EmitLn;

   | 134 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 134/620 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' FrameBase ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 135 :
  EmitNtRegOrCMemOrIm(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 135/445 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' RegOrCMemOrIm ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	mov');  EmitSuffix( e^.gcg^.RegOrCMemOrIm.mode);  CodeGen.EmitTab;  EmitAdrMode( AT0.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[ai].reg,e^.gcg^.RegOrCMemOrIm.mode);  CodeGen.EmitLn;

   | 136 :
  EmitNtmem(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 136/430 Cost=');
          WriteInt    (e^.gcg^.cost [ntreg],1);
          WriteString (' mem ->   reg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	IF (AT0.mem.am.offset = 0) AND
	   (AT0.mem.am.faktor = 1) AND
	   (AT0.mem.am.symbol = NullSymb) AND
	   (((AT0.mem.am.base  = RegAlloc.allocation[ai].reg) AND (AT0.mem.am.index = RegNil)) OR
	    ((AT0.mem.am.index = RegAlloc.allocation[ai].reg) AND (AT0.mem.am.base  = RegNil))) THEN
	  (* skip leal (reg),reg *)
	ELSE
 CodeGen.EmitString('	leal	');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].reg);  CodeGen.EmitLn;
	END;

   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrreg (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ;
      WITH RegAlloc.allocation[ai] DO
         IF spilllocation#0 THEN
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtreg;



(* ------------------------------------------------------------------------
 * Procedure EmitNtfreg  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtfreg (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes);
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntfreg] OF
   | 137 :
  EmitNtreg(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 137/2728 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	PushFStack;
 CodeGen.EmitString('	pushl	');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	fildl	(%esp)');  CodeGen.EmitLn;
 CodeGen.EmitString('	addl	$4,%esp');  CodeGen.EmitLn;

   | 138 :
  EmitNtCMem(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 138/2713 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	PushFStack;
 CodeGen.EmitString('	fildl	');  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitLn;

   | 139 :
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 139/2697 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	PushFStack;
 CodeGen.EmitString('	flds	RealOne_');  CodeGen.EmitLn;
 CodeGen.EmitString('	fpatan');  CodeGen.EmitLn;
	PopFStack;

   | 140 :
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 140/2686 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fcos');  CodeGen.EmitLn;
   | 141 :
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 141/2675 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fsin');  CodeGen.EmitLn;
   | 142 :
  EmitNtloadln2(e^.son[1]^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 142/2641 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	IF CurFStackSize < 2 THEN
	(* Es wurde RealLn2_ zwar geladen, aber dann wegen Funktionsaufrufen *)
	(* als Tempo in den Speicher ausgelagert. Deshalb wird RealLn2_      *)
	(* hier erneut geladen, die ersten beiden Stackregister vertauscht,  *)
	(* und die Markierung als Tempo (die Speicherstelle) geloescht.      *)
	(* Im Normalfall wird durch das Nichtterminalloadln2 die Konstante   *)
	(* RealLn2_ vor (!) der Auswertung des Funktionsarguments in RegAlloc.allocation[ai].reg*)
	(* auf den Floating-Point-Stack geladen.			     *)
 CodeGen.EmitString('	fldl	RealLn2_');  CodeGen.EmitLn;
 CodeGen.EmitString('	fxch	%st(1)');  CodeGen.EmitLn;
	FStackTempo[FStackStart+1] := NoTempo;
	INC (CurFStackSize);
	END;
 CodeGen.EmitString('	fyl2x');  CodeGen.EmitLn;
	PopFStack;

   | 143 :
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 143/2603 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	(* e^x = 2^(x * log2e) *)
 CodeGen.EmitString('	fmull	RealLog2e_');  CodeGen.EmitLn;
	(* Normierung noetig: Fuer f2xm1 muss -0.5 <= st <= +0.5 gelten *)
	(* Daher Aufteilung von x = hi + lo mit |lo| <= 0.5		*)
	(* Neues Register fuer hi, weil x noch gebraucht wird 		*)
	PushFStack;
 CodeGen.EmitString('	fld	%st');  CodeGen.EmitLn;
	(* Rundung hier zur naechsten ganzen Zahl, deshalb Aenderung    *)
	(* des Steuerwortes						*)
	CheckRoundMode (RndNearest);
 CodeGen.EmitString('	frndint');  CodeGen.EmitLn;
	(* Neues Register fuer lo, weil hi noch gebraucht wird 		*)
	PushFStack;
 CodeGen.EmitString('	fld	%st');  CodeGen.EmitLn;
	(* Differenz von x und hi -> lo					*)
 CodeGen.EmitString('	fsubr	%st(2),%st');  CodeGen.EmitLn;
	(* Berechnung von 2^lo						*)
 CodeGen.EmitString('	f2xm1');  CodeGen.EmitLn;
 CodeGen.EmitString('	fadds	RealOne_');  CodeGen.EmitLn;
	(* Berechnung 2^hi * 2^lo					*)
 CodeGen.EmitString('	fscale');  CodeGen.EmitLn;
	(* Benutzte Register wieder poppen (und Ergebnis weitergeben)	*)
 CodeGen.EmitString('	fstp	%st(1)');  CodeGen.EmitLn;
	PopFStack;
 CodeGen.EmitString('	fstp	%st(1)');  CodeGen.EmitLn;
	PopFStack;

   | 144 :
  EmitNtfreg(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 144/2592 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fsqrt');  CodeGen.EmitLn;
   | 145 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 145/2552 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	call	');  CodeGen.EmitString( e^.son[2]^.attr^.ProcedureConstant.index^.Entry^);  CodeGen.EmitLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 CodeGen.EmitString('	addl	$');  CodeGen.EmitInt( e^.attr^.FunctionCall.paramsize);  CodeGen.EmitString(', %esp');  CodeGen.EmitLn;
	END;
	PushFStack;

   | 146 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 146/2537 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FunctionCall ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	SpillFStack;
	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	call	');  EmitRegister(RegAlloc.allocation[ai].op[2]);  CodeGen.EmitLn;
	IF e^.attr^.FunctionCall.paramsize # 0 THEN
	(* e^.attr^.FunctionCall.paramsize := (e^.attr^.FunctionCall.paramsize+3) DIV 4 * 4; *)
 CodeGen.EmitString('	addl	$');  CodeGen.EmitInt( e^.attr^.FunctionCall.paramsize);  CodeGen.EmitString(', %esp');  CodeGen.EmitLn;
	END;
	PushFStack;

   | 147 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
  EmitNtCMem(e^.son[3],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 147/2010 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' CheckL ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	GetLabel(lab);
	GetLabel(lab2);
	IF e^.attr^.CheckL.CheckLwb THEN
 CodeGen.EmitString('	fcom');  EmitSuffix( e^.attr^.CheckL.LwbMode);  CodeGen.EmitTab;  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	jb	');  CodeGen.EmitString( lab2^);  CodeGen.EmitLn;
	END;
	IF e^.attr^.CheckL.CheckUpb THEN
 CodeGen.EmitString('	fcom');  EmitSuffix( e^.attr^.CheckL.UpbMode);  CodeGen.EmitTab;  EmitMemAdr( AT2.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	jbe	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
	ELSE
 CodeGen.EmitString('	jmp	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
	END;
 CodeGen.EmitString( lab2^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
 CodeGen.EmitString('   	call	BoundErr_		');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;

   | 148 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 148/1897 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Coerce ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 149 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 149/1760 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Float ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	GetLabel(lab);
	PushFStack;
 CodeGen.EmitString('	pushl	');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	fildl	(%esp)');  CodeGen.EmitLn;
 CodeGen.EmitString('	addl	$4,%esp');  CodeGen.EmitLn;
 CodeGen.EmitString('	cmpl	$0x7fffffff,');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	jbe	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
 CodeGen.EmitString('	faddl	TwoExp32_');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;

   | 150 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 150/1748 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' Float ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	GetLabel(lab);
	PushFStack;
 CodeGen.EmitString('	fildl	');  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	cmpl	$0x7fffffff,');  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	jbe	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
 CodeGen.EmitString('	faddl	TwoExp32_');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;

   | 151 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 151/1582 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatAbs ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fabs ');  CodeGen.EmitLn;
   | 152 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtfstack(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 152/1577 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 FloatOperation ('fdivr');
   | 153 :
  EmitNtfstack(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 153/1572 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 FloatOperation ('fdiv');
   | 154 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 154/1567 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fdivr');  EmitSuffix( e^.attr^.FloatDiv.mode);  CodeGen.EmitTab;  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 155 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 155/1562 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatDiv ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fdiv');  EmitSuffix( e^.attr^.FloatDiv.mode);  CodeGen.EmitTab;  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 156 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtfstack(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 156/1557 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 FloatOperation ('fmul');
   | 157 :
  EmitNtfstack(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 157/1557 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 FloatOperation ('fmul');
   | 158 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 158/1552 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fmul');  EmitSuffix( e^.attr^.FloatMult.mode);  CodeGen.EmitTab;  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 159 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 159/1552 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMult ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fmul');  EmitSuffix( e^.attr^.FloatMult.mode);  CodeGen.EmitTab;  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 160 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtfstack(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 160/1547 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 FloatOperation ('fsub');
   | 161 :
  EmitNtfstack(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 161/1542 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 FloatOperation ('fsubr');
   | 162 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 162/1537 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fsubr');  EmitSuffix( e^.attr^.FloatMinus.mode);  CodeGen.EmitTab;  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 163 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 163/1532 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatMinus ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fsub');  EmitSuffix( e^.attr^.FloatMinus.mode);  CodeGen.EmitTab;  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 164 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtfstack(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 164/1527 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 FloatOperation ('fadd');
   | 165 :
  EmitNtfstack(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 165/1527 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 FloatOperation ('fadd');
   | 166 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 166/1522 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fadd');  EmitSuffix( e^.attr^.FloatPlus.mode);  CodeGen.EmitTab;  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 167 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 167/1522 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatPlus ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fadd');  EmitSuffix( e^.attr^.FloatPlus.mode);  CodeGen.EmitTab;  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
   | 168 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 168/1517 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' FloatNegate ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 CodeGen.EmitString('	fchs ');  CodeGen.EmitLn;
   | 169 :
  EmitNtCMem(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 169/490 Cost=');
          WriteInt    (e^.gcg^.cost [ntfreg],1);
          WriteString (' CMem ->   freg');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	PushFStack;
 CodeGen.EmitString('	fld');  EmitSuffix( e^.gcg^.CMem.mode);
 CodeGen.EmitTab;  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitLn;

   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrfreg (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ;
      WITH RegAlloc.allocation[ai] DO
         IF spilllocation#0 THEN
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtfreg;


(* ------------------------------------------------------------------------
 * Procedure EmitNtfstack  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtfstack (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes);
VAR
    AT0   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntfstack] OF
   | 170 :
  EmitNtfreg(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 170/497 Cost=');
          WriteInt    (e^.gcg^.cost [ntfstack],1);
          WriteString (' freg ->   fstack');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	IF EmitAnnotations THEN
 CodeGen.EmitString('					/* Kettenregel ');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitString(' -> ');  EmitRegister(RegAlloc.allocation[ai].reg);  CodeGen.EmitString(' */');  CodeGen.EmitLn;
	END;

   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrfstack (resAttributes);
       WriteLn;
   END;
   IF RegAlloc.allocation [ai].actionafter THEN  (* ++ he 08/91 *)
 ;
      WITH RegAlloc.allocation[ai] DO
         IF spilllocation#0 THEN
            Spill (reg, spilllocation);
            IF IR.OptEmitMatch THEN
                WriteString (' Spill Register ');
                PrintRegister (reg);
                WriteString (' into ');
                WriteInt (spilllocation,1);
                WriteLn;
            END;
         ELSE
            LR (regmove, reg);
            IF IR.OptEmitMatch THEN
                WriteString (' Copy Register ');
                PrintRegister (reg);
                WriteString (' into ');
                PrintRegister (regmove);
                WriteLn;
            END;
         END;
      END;
   END;                                           (* -- he 08/91 *)
END EmitNtfstack;


(* ------------------------------------------------------------------------
 * Procedure EmitNtConstant  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtConstant (e : IR.Expression; nest : INTEGER
       ; VAR resAttributes : NtAttributes);
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;

BEGIN
   CASE e^.gcg^.rule [ntConstant] OF
   | 171 :
  EmitNtFloatConstant(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 171/2821 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FunctionCall ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 172 :
  EmitNtFloatConstant(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 172/2779 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FunctionCall ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 173 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 173/1823 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' Coerce ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 174 :
  EmitNtFloatConstant(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 174/1778 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' Trunc ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 175 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 175/1455 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMod ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 176 :
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 176/1411 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedDiv ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 177 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 177/1338 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedDiv ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 178 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 178/1135 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 179 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 179/1135 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 180 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 180/1131 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMult ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 181 :
  EmitNtSimpleVariable(e^.son[1]^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 181/1123 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMinus ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 182 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 182/1041 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedMinus ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 183 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 183/935 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedPlus ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 184 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 184/910 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedAbs ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 185 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 185/898 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' FixedNegate ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 186 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 186/544 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' NilConstant ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 187 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 187/540 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' SetConstant ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 188 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 188/535 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' BoolConstant ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 189 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 189/531 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' CharConstant ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 190 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 190/519 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' LongIntConstant ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 191 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 191/515 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' ShortIntConstant ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 192 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 192/511 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' LongCardConstant ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 193 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 193/507 Cost=');
          WriteInt    (e^.gcg^.cost [ntConstant],1);
          WriteString (' ShortCardConstant ->   Constant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrConstant (resAttributes);
       WriteLn;
   END;
END EmitNtConstant;


(* ------------------------------------------------------------------------
 * Procedure EmitNtFloatConstant  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtFloatConstant
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntFloatConstant] OF
  | 194 :
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 194/2755 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' FunctionCall ->   FloatConstant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 195 :
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 195/2745 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' FunctionCall ->   FloatConstant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 196 :
  EmitNtFloatConstant(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 196/1892 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Coerce ->   FloatConstant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 197 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 197/1887 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Coerce ->   FloatConstant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 198 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 198/1774 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' Float ->   FloatConstant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 199 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 199/527 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' LongRealConstant ->   FloatConstant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 200 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 200/523 Cost=');
          WriteInt    (e^.gcg^.cost [ntFloatConstant],1);
          WriteString (' RealConstant ->   FloatConstant');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrFloatConstant (resAttributes);
       WriteLn;
   END;
END EmitNtFloatConstant;


(* ------------------------------------------------------------------------
 * Procedure EmitNtSimpleVariable  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtSimpleVariable
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
  AT1   :  NtAttributes;
  AT2   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntSimpleVariable] OF
  | 201 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 201/1190 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 202 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1]^.son[1],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 202/1190 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 203 :
  EmitNtSimpleVariable(e^.son[1]^.son[1]^.son[1]^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[1]^.son[2],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 203/1190 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 204 :
  EmitNtConstant(e^.son[1]^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[1]^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2],nest+1,AT2 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 204/1190 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 205 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 205/1085 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedMinus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 206 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 206/988 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 207 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 207/988 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 208 :
  EmitNtConstant(e^.son[2],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 208/634 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 SaveDisplay [e^.son[1]^.attr^.FrameBase.level] := TRUE;
   | 209 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 209/634 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' FixedPlus ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 SaveDisplay [e^.son[2]^.attr^.FrameBase.level] := TRUE;
   | 210 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 210/579 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' StaticVariable ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   | 211 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 211/559 Cost=');
          WriteInt    (e^.gcg^.cost [ntSimpleVariable],1);
          WriteString (' LocalVariable ->   SimpleVariable');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrSimpleVariable (resAttributes);
       WriteLn;
   END;
END EmitNtSimpleVariable;


(* ------------------------------------------------------------------------
 * Procedure EmitNtSymPlusOffset  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtSymPlusOffset
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
  AT1   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntSymPlusOffset] OF
  | 212 :
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 212/1828 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' Coerce ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol;
   | 213 :
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 213/1045 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedMinus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol;
   | 214 :
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 214/939 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedPlus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.SymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol;
   | 215 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 215/939 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' FixedPlus ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.SymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol;
   | 216 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 216/591 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' StaticVariable ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.StaticVariable.module^.Statics;
   | 217 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 217/552 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' StringAddr ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.StringAddr.index;
   | 218 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 218/548 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' ProcedureConstant ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.SymPlusOffset.symbol	:= e^.attr^.ProcedureConstant.index^.Entry;
   | 219 :
  EmitNtConstant(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 219/332 Cost=');
          WriteInt    (e^.gcg^.cost [ntSymPlusOffset],1);
          WriteString (' Constant ->   SymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.SymPlusOffset.symbol	:= NullSymb;
   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrSymPlusOffset (resAttributes);
       WriteLn;
   END;
END EmitNtSymPlusOffset;


(* ------------------------------------------------------------------------
 * Procedure EmitNtRegPlusSymPlusOffset  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtRegPlusSymPlusOffset
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes);
VAR
  AT0   :  NtAttributes;
  AT1   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntRegPlusSymPlusOffset] OF
  | 220 :
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 220/1834 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' Coerce ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol;
   | 221 :
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 221/1065 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol;
   | 222 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 222/1055 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[1];
	resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
 CodeGen.EmitString('	mov');  EmitSigned( e^.son[1]^.gcg^.reg.mode);  EmitSuffix( e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitString('l	');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;

   | 223 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 223/1049 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedMinus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
   | 224 :
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 224/959 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.RegPlusSymPlusOffset.symbol;
   | 225 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtRegPlusSymPlusOffset(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 225/959 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= AT1.RegPlusSymPlusOffset.base;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.RegPlusSymPlusOffset.symbol;
   | 226 :
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 226/949 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[2];
	resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol;
 CodeGen.EmitString('	mov');  EmitSigned( e^.son[2]^.gcg^.reg.mode);  EmitSuffix( e^.son[2]^.gcg^.reg.mode);  CodeGen.EmitString('l	');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.son[2]^.gcg^.reg.mode);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].op[2]);  CodeGen.EmitLn;

   | 227 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 227/949 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[1];
	resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol;
 CodeGen.EmitString('	mov');  EmitSigned( e^.son[1]^.gcg^.reg.mode);  EmitSuffix( e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitString('l	');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.son[1]^.gcg^.reg.mode);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;

   | 228 :
  EmitNtSymPlusOffset(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 228/943 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[2];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol;
   | 229 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtSymPlusOffset(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 229/943 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' FixedPlus ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1];
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT1.SymPlusOffset.symbol;
   | 230 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 230/571 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' LocalVariable ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= Regebp;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
   | 231 :
  EmitNtreg(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 231/347 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' reg ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
	resAttributes.RegPlusSymPlusOffset.base		:= RegAlloc.allocation[ai].op[1];
 CodeGen.EmitString('	mov');  EmitSigned( e^.gcg^.reg.mode);  EmitSuffix( e^.gcg^.reg.mode);  CodeGen.EmitString('l	');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.gcg^.reg.mode);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;

   | 232 :
  EmitNtreg(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 232/341 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' reg ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.symbol	:= NullSymb;
	  resAttributes.RegPlusSymPlusOffset.base	:= RegAlloc.allocation[ai].op[1];
   | 233 :
  EmitNtSymPlusOffset(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 233/336 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegPlusSymPlusOffset],1);
          WriteString (' SymPlusOffset ->   RegPlusSymPlusOffset');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegPlusSymPlusOffset.base	:= RegNil;
	  resAttributes.RegPlusSymPlusOffset.symbol	:= AT0.SymPlusOffset.symbol;
   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrRegPlusSymPlusOffset (resAttributes);
       WriteLn;
   END;
END EmitNtRegPlusSymPlusOffset;


(* ------------------------------------------------------------------------
 * Procedure EmitNtOffsetPlusIndexMultFaktor  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtOffsetPlusIndexMultFaktor
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
  AT1   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntOffsetPlusIndexMultFaktor] OF
  | 234 :
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 234/1841 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' Coerce ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index;
   | 235 :
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 235/1354 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedDiv ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT0.OffsetPlusIndexMultFaktor.index;
   | 236 :
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 236/1170 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMult ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT0.OffsetPlusIndexMultFaktor.index;
   | 237 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 237/1170 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMult ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index  := AT1.OffsetPlusIndexMultFaktor.index;
   | 238 :
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 238/1070 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedMinus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index;
   | 239 :
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 239/964 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedPlus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT0.OffsetPlusIndexMultFaktor.index;
   | 240 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 240/964 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' FixedPlus ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= AT1.OffsetPlusIndexMultFaktor.index;
   | 241 :
  EmitNtreg(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 241/363 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' reg ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	resAttributes.OffsetPlusIndexMultFaktor.index		:= RegAlloc.allocation[ai].op[1];
 CodeGen.EmitString('	mov');  EmitSigned( e^.gcg^.reg.mode);  EmitSuffix( e^.gcg^.reg.mode);  CodeGen.EmitString('l	');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.gcg^.reg.mode);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[ai].op[1]);  CodeGen.EmitLn;

   | 242 :
  EmitNtreg(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 242/357 Cost=');
          WriteInt    (e^.gcg^.cost [ntOffsetPlusIndexMultFaktor],1);
          WriteString (' reg ->   OffsetPlusIndexMultFaktor');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.OffsetPlusIndexMultFaktor.index	:= RegAlloc.allocation[ai].op[1];
   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrOffsetPlusIndexMultFaktor (resAttributes);
       WriteLn;
   END;
END EmitNtOffsetPlusIndexMultFaktor;


(* ------------------------------------------------------------------------
 * Procedure EmitNtmem  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtmem
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
  AT1   :  NtAttributes;
BEGIN
   CASE e^.gcg^.rule [ntmem] OF
   | 243 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 243/1848 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' Coerce ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol;
   | 244 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 244/1259 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[2]^.gcg^.Constant.val DIV 9));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;
	  resAttributes.mem.am.faktor := 8;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;

   | 245 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 245/1259 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[1]^.gcg^.Constant.val DIV 9));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;
	  resAttributes.mem.am.faktor := 8;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;

   | 246 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 246/1244 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[2]^.gcg^.Constant.val DIV 5));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;
	  resAttributes.mem.am.faktor := 4;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;

   | 247 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 247/1244 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[1]^.gcg^.Constant.val DIV 5));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;
	  resAttributes.mem.am.faktor := 4;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;

   | 248 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 248/1229 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[2]^.gcg^.Constant.val DIV 3));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[1],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;
	  resAttributes.mem.am.faktor := 2;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[1];
	  resAttributes.mem.am.symbol := NullSymb;

   | 249 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 249/1229 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.FixedMult.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[1]^.gcg^.Constant.val DIV 3));  CodeGen.EmitString(', ');  EmitRegister2 ( RegAlloc.allocation[ai].op[2],e^.attr^.FixedMult.mode);  CodeGen.EmitLn;
	  resAttributes.mem.am.faktor := 2;
	  resAttributes.mem.am.offset := 0;
	  resAttributes.mem.am.index  := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.base   := RegAlloc.allocation[ai].op[2];
	  resAttributes.mem.am.symbol := NullSymb;

   | 250 :
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 250/1179 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.faktor := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[2]^.gcg^.Constant.val - 1;
	  resAttributes.mem.am.offset := e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.index  := AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.base   := AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol := NullSymb;
   | 251 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 251/1179 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMult ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.faktor := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor * e^.son[1]^.gcg^.Constant.val - 1;
	  resAttributes.mem.am.offset := e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset * e^.son[1]^.gcg^.Constant.val;
	  resAttributes.mem.am.index  := AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.base   := AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol := NullSymb;
   | 252 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 252/1076 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedMinus ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset - e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol;
   | 253 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 253/979 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.offset	:= AT0.mem.am.offset + e^.son[2]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT0.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT0.mem.am.base;
	  resAttributes.mem.am.index	:= AT0.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT0.mem.am.symbol;
   | 254 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtmem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 254/979 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.offset	:= AT1.mem.am.offset + e^.son[1]^.gcg^.Constant.val;
	  resAttributes.mem.am.faktor	:= AT1.mem.am.faktor;
	  resAttributes.mem.am.base	:= AT1.mem.am.base;
	  resAttributes.mem.am.index	:= AT1.mem.am.index;
	  resAttributes.mem.am.symbol	:= AT1.mem.am.symbol;
   | 255 :
  EmitNtOffsetPlusIndexMultFaktor(e^.son[1],nest+1,AT0 );
  EmitNtRegPlusSymPlusOffset(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 255/970 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.offset	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[2]^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= e^.son[1]^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= AT1.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= AT1.RegPlusSymPlusOffset.symbol;
   | 256 :
  EmitNtRegPlusSymPlusOffset(e^.son[1],nest+1,AT0 );
  EmitNtOffsetPlusIndexMultFaktor(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 256/970 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' FixedPlus ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.offset	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.offset + e^.son[1]^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= e^.son[2]^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= AT1.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= AT0.RegPlusSymPlusOffset.symbol;
   | 257 :
  EmitNtOffsetPlusIndexMultFaktor(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 257/382 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' OffsetPlusIndexMultFaktor ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.offset	:= e^.gcg^.OffsetPlusIndexMultFaktor.offset;
	  resAttributes.mem.am.faktor	:= e^.gcg^.OffsetPlusIndexMultFaktor.faktor;
	  resAttributes.mem.am.base	:= RegNil;
	  resAttributes.mem.am.index	:= AT0.OffsetPlusIndexMultFaktor.index;
	  resAttributes.mem.am.symbol	:= NullSymb;
   | 258 :
  EmitNtRegPlusSymPlusOffset(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 258/373 Cost=');
          WriteInt    (e^.gcg^.cost [ntmem],1);
          WriteString (' RegPlusSymPlusOffset ->   mem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.mem.am.offset	:= e^.gcg^.RegPlusSymPlusOffset.offset;
	  resAttributes.mem.am.faktor	:= 1;
	  resAttributes.mem.am.base	:= AT0.RegPlusSymPlusOffset.base;
	  resAttributes.mem.am.index	:= RegNil;
	  resAttributes.mem.am.symbol	:= AT0.RegPlusSymPlusOffset.symbol;
   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrmem (resAttributes);
       WriteLn;
   END;
END EmitNtmem;


(* ------------------------------------------------------------------------
 * Procedure EmitNtCMem  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtCMem
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntCMem] OF
  | 259 :
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 259/1917 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	DeclareTransferTempo;
	resAttributes.CMem.am.offset	:= TransferTempo;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= Regebp;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= NullSymb;
 CodeGen.EmitString('	mov');  EmitSuffix( e^.attr^.Coerce.premode);
 CodeGen.EmitTab;  EmitAdrMode( AT0.RegOrIm.am); CodeGen.EmitChar(',');
 EmitMemAdr( resAttributes.CMem.am);  CodeGen.EmitLn;

   | 260 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 260/1901 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	DeclareTransferTempo;
	resAttributes.CMem.am.offset	:= TransferTempo;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= Regebp;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= NullSymb;
 CodeGen.EmitString('	fstp');  EmitSuffix( e^.attr^.Coerce.premode);
 CodeGen.EmitTab; EmitMemAdr( resAttributes.CMem.am);  CodeGen.EmitLn;
	PopFStack;

   | 261 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 261/1859 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Coerce ->   CMem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.CMem.am.offset	:= AT0.CMem.am.offset;
	  resAttributes.CMem.am.faktor	:= AT0.CMem.am.faktor;
	  resAttributes.CMem.am.base	:= AT0.CMem.am.base;
	  resAttributes.CMem.am.index	:= AT0.CMem.am.index;
	  resAttributes.CMem.am.symbol	:= AT0.CMem.am.symbol;
   | 262 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 262/689 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' Content ->   CMem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.CMem.am	 := AT0.mem.am;
   | 263 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 263/624 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FrameBase ->   CMem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.CMem.am.offset	:= 4*e^.attr^.FrameBase.level;
	  resAttributes.CMem.am.faktor	:= 0;
	  resAttributes.CMem.am.base	:= RegNil;
	  resAttributes.CMem.am.index	:= RegNil;
	  resAttributes.CMem.am.symbol	:= DisplaySym;
	  SaveDisplay [e^.attr^.FrameBase.level] := TRUE;
   | 264 :
  EmitNtFloatConstant(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 264/471 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FloatConstant ->   CMem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	GetLabel (lab);
	resAttributes.CMem.am.offset	:= 0;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= RegNil;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= lab;
	tr2.r := e^.gcg^.FloatConstant.val;
	ConvertREALtoString (e^.gcg^.FloatConstant.val, str);
 CodeGen.EmitString('	.data');  CodeGen.EmitLn;
 CodeGen.EmitString('	.align 4');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
 CodeGen.EmitString('	.long	');  CodeGen.EmitInt( tr2.c2);  CodeGen.EmitChar(',');  CodeGen.EmitInt( tr2.c1);  CodeGen.EmitString('		# ');  CodeGen.EmitString( str);  CodeGen.EmitLn;
 CodeGen.EmitString('	.text');  CodeGen.EmitLn;

   | 265 :
  EmitNtFloatConstant(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 265/452 Cost=');
          WriteInt    (e^.gcg^.cost [ntCMem],1);
          WriteString (' FloatConstant ->   CMem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	GetLabel (lab);
	resAttributes.CMem.am.offset	:= 0;
	resAttributes.CMem.am.faktor	:= 0;
	resAttributes.CMem.am.base	:= RegNil;
	resAttributes.CMem.am.index	:= RegNil;
	resAttributes.CMem.am.symbol	:= lab;
	tr1.r := e^.gcg^.FloatConstant.val;
	ConvertREALtoString (e^.gcg^.FloatConstant.val, str);
 CodeGen.EmitString('	.data');  CodeGen.EmitLn;
 CodeGen.EmitString('	.align 4');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
 CodeGen.EmitString('	.long	');  CodeGen.EmitInt( tr1.c);  CodeGen.EmitString('		# ');  CodeGen.EmitString( str);  CodeGen.EmitLn;
 CodeGen.EmitString('	.text');  CodeGen.EmitLn;

   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrCMem (resAttributes);
       WriteLn;
   END;
END EmitNtCMem;


(* ------------------------------------------------------------------------
 * Procedure EmitNtRegOrIm  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtRegOrIm
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
BEGIN
   CASE e^.gcg^.rule [ntRegOrIm] OF
   | 266 :
  EmitNtConstant(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 266/418 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrIm],1);
          WriteString (' Constant ->   RegOrIm');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegOrIm.am.kind  := Mconst;
	  resAttributes.RegOrIm.am.mode  := e^.gcg^.Constant.mode;
	  resAttributes.RegOrIm.am.constant := e^.gcg^.Constant.val;
   | 267 :
  EmitNtreg(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 267/391 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrIm],1);
          WriteString (' reg ->   RegOrIm');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegOrIm.am.kind := Mreg;
	  resAttributes.RegOrIm.am.mode := e^.gcg^.reg.mode;
	  resAttributes.RegOrIm.am.reg  := RegAlloc.allocation[ai].op[1];
   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrRegOrIm (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrIm;


(* ------------------------------------------------------------------------
 * Procedure EmitNtRegOrCMem  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtRegOrCMem
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntRegOrCMem] OF
  | 268 :
  EmitNtCMem(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 268/403 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMem],1);
          WriteString (' CMem ->   RegOrCMem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegOrCMem.am.kind := Mmem;
	  resAttributes.RegOrCMem.am.mode := e^.gcg^.CMem.mode;
	  resAttributes.RegOrCMem.am.mem  := AT0.CMem.am;
   | 269 :
  EmitNtreg(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 269/397 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMem],1);
          WriteString (' reg ->   RegOrCMem');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegOrCMem.am.kind := Mreg;
	  resAttributes.RegOrCMem.am.mode := e^.gcg^.reg.mode;
	  resAttributes.RegOrCMem.am.reg  := RegAlloc.allocation[ai].op[1];
   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrRegOrCMem (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrCMem;


(* ------------------------------------------------------------------------
 * Procedure EmitNtRegOrCMemOrIm  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtRegOrCMemOrIm
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntRegOrCMemOrIm] OF
  | 270 :
  EmitNtConstant(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 270/424 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMemOrIm],1);
          WriteString (' Constant ->   RegOrCMemOrIm');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegOrCMemOrIm.am.kind  := Mconst;
	  resAttributes.RegOrCMemOrIm.am.mode  := e^.gcg^.Constant.mode;
	  resAttributes.RegOrCMemOrIm.am.constant := e^.gcg^.Constant.val;
   | 271 :
  EmitNtRegOrCMem(e,nest+1,AT0 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 271/409 Cost=');
          WriteInt    (e^.gcg^.cost [ntRegOrCMemOrIm],1);
          WriteString (' RegOrCMem ->   RegOrCMemOrIm');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;
 resAttributes.RegOrCMemOrIm.am.kind := AT0.RegOrCMem.am.kind;
	  resAttributes.RegOrCMemOrIm.am.mode := e^.gcg^.RegOrCMem.mode;
	  IF AT0.RegOrCMem.am.kind = Mreg
	    THEN resAttributes.RegOrCMemOrIm.am.reg := AT0.RegOrCMem.am.reg;
	    ELSE resAttributes.RegOrCMemOrIm.am.mem := AT0.RegOrCMem.am.mem;
	  END;
   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrRegOrCMemOrIm (resAttributes);
       WriteLn;
   END;
END EmitNtRegOrCMemOrIm;


(* ------------------------------------------------------------------------
 * Procedure EmitNtarglist  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtarglist
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
  AT0   :  NtAttributes;
  AT1   :  NtAttributes;
BEGIN
  CASE e^.gcg^.rule [ntarglist] OF
  | 272 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 272/2471 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' PassLong ->   arglist');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	subl	$');  CodeGen.EmitInt( e^.attr^.PassLong.space);  CodeGen.EmitString(',%esp');  CodeGen.EmitLn;
 CodeGen.EmitString('	movl	%esp,%edi');  CodeGen.EmitLn;
 CodeGen.EmitString('	movl	$');  CodeGen.EmitInt( (e^.attr^.PassLong.size + 3) DIV 4);  CodeGen.EmitString(',%ecx');  CodeGen.EmitLn;
 CodeGen.EmitString('	cld');  CodeGen.EmitLn;
 CodeGen.EmitString('	repz');  CodeGen.EmitLn;
 CodeGen.EmitString('	movsl');  CodeGen.EmitLn;

   | 273 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
  EmitNtmem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 273/2461 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' PassLong ->   arglist');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	IF e^.attr^.PassLong.space > 4 THEN
 CodeGen.EmitString('	subl	$');  CodeGen.EmitInt( e^.attr^.PassLong.space - 4);  CodeGen.EmitString(',%esp');  CodeGen.EmitLn;
	END;
 CodeGen.EmitString('	pushl	');  EmitMemAdr( AT1.mem.am);  CodeGen.EmitLn;

   | 274 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 274/2452 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	subl	$');  CodeGen.EmitInt( SizeTable[e^.attr^.Pass.mode]);  CodeGen.EmitString(',%esp');  CodeGen.EmitLn;
 CodeGen.EmitString('	fstp');  EmitSuffix( e^.attr^.Pass.mode);  CodeGen.EmitString('	(%esp)');  CodeGen.EmitLn;
	PopFStack;

   | 275 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 275/2442 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	INC (AT1.CMem.am.offset, 4);
 CodeGen.EmitString('	pushl	');  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitLn;
	DEC (AT1.CMem.am.offset, 4);
 CodeGen.EmitString('	pushl	');  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitLn;

   | 276 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 276/2436 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	pushl	$');  CodeGen.EmitInt( e^.son[2]^.gcg^.Constant.val);  CodeGen.EmitLn;

   | 277 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 277/2418 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Pass ->   arglist');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

 CodeGen.EmitString('	pushl	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitLn;

   | 278 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 278/2416 Cost=');
          WriteInt    (e^.gcg^.cost [ntarglist],1);
          WriteString (' Nil ->   arglist');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrarglist (resAttributes);
       WriteLn;
   END;
END EmitNtarglist;


(* ------------------------------------------------------------------------
 * Procedure EmitNtloadln2  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitNtloadln2
  ( e : IR.Expression; nest : INTEGER; VAR resAttributes : NtAttributes );
VAR
BEGIN
   CASE e^.gcg^.rule [ntloadln2] OF
   | 279 :
       ai:=ai-1;
       IF RegAlloc.allocation [ai]. num>0 THEN
          PerformActions (ai);
       END;
       IF IR.OptEmitMatch THEN
          WriteNest (nest);
          WriteString ('Rule 279/2668 Cost=');
          WriteInt    (e^.gcg^.cost [ntloadln2],1);
          WriteString (' Nil ->   loadln2');
          WriteLn;
          WriteNest (nest);
          WriteCard (CARDINAL(e),1); Write(' ');
          IF e#NIL THEN IR.PrintAttributes (e^.attr^); ELSE WriteLn; END;
          WriteNest (nest);
          RegAlloc.PrintAllocation (ai);
       END;

	PushFStack;
 CodeGen.EmitString('	fldl	RealLn2_');  CodeGen.EmitLn;

   END;
   IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteAttrloadln2 (resAttributes);
       WriteLn;
   END;
END EmitNtloadln2;


(* ------------------------------------------------------------------------
 * Procedure EmitStatement  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitStatement ( e : IR.Expression );
CONST nest = 0;
VAR
    AT0   :  NtAttributes;
    AT1   :  NtAttributes;
    AT2   :  NtAttributes;

VAR   i        : INTEGER;
BEGIN
   ai := RegAlloc.ai;
   IF e^.gcg^.stmtcost >= IR.infcost THEN
     (*************** Compiler Error ******************)
     (******** No code selected, no cover found *******)
     WriteString ('no code selected'); WriteLn;
     IR.PrintInstrCosts (e);
     WriteLn;
     IR.Error ('internal error');
     i := 0; i := 1 DIV i; HALT;
   ELSE
     CASE e^.gcg^.stmtrule OF
     | 1 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 1/696 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CodeGen.EmitString('	mov');  EmitSuffix( e^.attr^.Assign.mode);
 CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
     | 2 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 2/701 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 CodeGen.EmitString('	fstp');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;
	PopFStack;

     | 3 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtFloatConstant(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 3/709 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	tr1.r := e^.son[2]^.gcg^.FloatConstant.val;
 CodeGen.EmitString('	movl	$');  CodeGen.EmitInt( tr1.c);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;

     | 4 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtFloatConstant(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 4/717 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	tr2.r := e^.son[2]^.gcg^.FloatConstant.val;
 CodeGen.EmitString('	movl	$');  CodeGen.EmitInt( tr2.c2);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;
	INC (AT0.mem.am.offset, 4);
 CodeGen.EmitString('	movl	$');  CodeGen.EmitInt( tr2.c1);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitTab;  CodeGen.EmitLn;

     | 5 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 5/727 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 CodeGen.EmitString('	movl	');  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	movl	');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;

     | 6 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 6/736 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 CodeGen.EmitString('	movl	');  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	movl	');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;
	INC (AT0.mem.am.offset, 4);
	INC (AT1.CMem.am.offset, 4);
 CodeGen.EmitString('	movl	');  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	movl	');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;

     | 7 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 7/749 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 8 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtmem(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 8/773 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' AssignLong');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

 CodeGen.EmitString('	leal	');  EmitMemAdr( AT1.mem.am);  CodeGen.EmitString(',%esi');  CodeGen.EmitLn;
 CodeGen.EmitString('	leal	');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitString(',%edi');  CodeGen.EmitLn;
	IF AT0.mem.am.offset MOD 4 >= 1 THEN
	  DEC (e^.attr^.AssignLong.size, 4-(AT0.mem.am.offset MOD 4));
	END;
	IF e^.attr^.AssignLong.size >= 4 THEN
 CodeGen.EmitString('	movl	$');  CodeGen.EmitInt( e^.attr^.AssignLong.size DIV 4);  CodeGen.EmitString(',%ecx');  CodeGen.EmitLn;
	END;
 CodeGen.EmitString('	cld');  CodeGen.EmitLn;
	IF AT0.mem.am.offset MOD 2 = 1 THEN
 CodeGen.EmitString('	movsb');  CodeGen.EmitLn;
	END;
	IF (AT0.mem.am.offset MOD 4 = 1) OR (AT0.mem.am.offset MOD 4 = 2) THEN
 CodeGen.EmitString('	movsw');  CodeGen.EmitLn;
	END;
	IF e^.attr^.AssignLong.size >= 8 THEN
 CodeGen.EmitString('	repz');  CodeGen.EmitLn;
	END;
	IF e^.attr^.AssignLong.size >= 4 THEN
 CodeGen.EmitString('	movsl');  CodeGen.EmitLn;
	END;
	IF e^.attr^.AssignLong.size MOD 4 >= 2 THEN
 CodeGen.EmitString('	movsw');  CodeGen.EmitLn;
	END;
	IF e^.attr^.AssignLong.size MOD 2 >= 1 THEN
 CodeGen.EmitString('	movsb');  CodeGen.EmitLn;
	END;

     | 9 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtmem(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 9/807 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' AssignLong');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.AssignLong.size >= 4 THEN
 CodeGen.EmitString('	movl	');  EmitMemAdr( AT1.mem.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	movl	');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;
	INC (AT1.mem.am.offset, 4);
	INC (AT0.mem.am.offset, 4);
	DEC (e^.attr^.AssignLong.size, 4);
	END;
	IF e^.attr^.AssignLong.size >= 4 THEN
 CodeGen.EmitString('	movl	');  EmitMemAdr( AT1.mem.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	movl	');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;
	INC (AT1.mem.am.offset, 4);
	INC (AT0.mem.am.offset, 4);
	DEC (e^.attr^.AssignLong.size, 4);
	END;
	IF e^.attr^.AssignLong.size DIV 2 > 0 THEN
 CodeGen.EmitString('	movw	');  EmitMemAdr( AT1.mem.am);  CodeGen.EmitChar(',');  EmitWordRegister ( RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	movw	');  EmitWordRegister ( RegAlloc.allocation[1].scr[1]);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;
	INC (AT1.mem.am.offset, 2);
	INC (AT0.mem.am.offset, 2);
	END;
	IF e^.attr^.AssignLong.size MOD 2 > 0 THEN
 CodeGen.EmitString('	movb	');  EmitMemAdr( AT1.mem.am);  CodeGen.EmitChar(',');  EmitByteRegister ( RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	movb	');  EmitByteRegister ( RegAlloc.allocation[1].scr[1]);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;
	END;

     | 10 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 10/838 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Inc1');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CodeGen.EmitString('	inc');  EmitSuffix( e^.attr^.Inc1.mode);  CodeGen.EmitTab;  EmitMemAdr( AT0.mem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
     | 11 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 11/842 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Dec1');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CodeGen.EmitString('	dec');  EmitSuffix( e^.attr^.Dec1.mode);  CodeGen.EmitTab;  EmitMemAdr( AT0.mem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
     | 12 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 12/846 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Inc2');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CodeGen.EmitString('	add');  EmitSuffix( e^.attr^.Inc2.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
     | 13 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 13/850 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Dec2');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CodeGen.EmitString('	sub');  EmitSuffix( e^.attr^.Dec2.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
     | 14 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 14/865 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' InclL');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CodeGen.EmitString('	btsl	');  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
     | 15 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 15/882 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ExclL');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CodeGen.EmitString('	btrl	');  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitChar(' ');  CodeGen.EmitLn;
     | 16 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 16/889 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SkipAddress');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 17 :
  EmitNtRegOrCMemOrIm(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 17/892 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SkipData');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 18 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 18/999 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	inc');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 19 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 19/999 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	inc');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 20 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 20/1013 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	add');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 21 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 21/1013 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	add');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitAdrMode( AT2.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 22 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 22/1026 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitString('	$1, ');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 23 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 23/1096 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	dec');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 24 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 24/1110 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	sub');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitAdrMode( AT2.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 25 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 25/1145 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 26 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 26/1145 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 27 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtConstant(e^.son[2]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 27/1214 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[2]^.son[1]^.gcg^.Constant.val));  CodeGen.EmitString(', ');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 28 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 28/1214 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	shl');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[2]^.son[2]^.gcg^.Constant.val));  CodeGen.EmitString(', ');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 29 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 29/1300 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	mov');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	imul');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	mov');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitTab;  EmitRegister2 ( RegAlloc.allocation[1].scr[2],e^.attr^.Assign.mode);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 30 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 30/1373 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	shr');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[2]^.son[2]^.gcg^.Constant.val));  CodeGen.EmitString(', ');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 31 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 31/1396 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	sar');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( Log2(e^.son[2]^.son[2]^.gcg^.Constant.val));  CodeGen.EmitString(', ');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 32 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 32/1467 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	and');  EmitSuffix( e^.attr^.Assign.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( e^.son[2]^.son[2]^.gcg^.Constant.val-1);  CodeGen.EmitString(', ');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 33 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 33/1596 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	orl	');  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 34 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 34/1596 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	orl	');  EmitAdrMode( AT2.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 35 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtreg(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 35/1626 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	notl	');  EmitRegister(RegAlloc.allocation[1].op[3]);  CodeGen.EmitLn;
 CodeGen.EmitString(' 	andl	');  EmitRegister(RegAlloc.allocation[1].op[3]);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 36 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtConstant(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 36/1640 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString(' 	andl	$');  CodeGen.EmitInt( INTEGER(BITSET(-1) - BITSET(e^.son[2]^.son[2]^.gcg^.Constant.val)));  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 37 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 37/1659 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	andl	');  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 38 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 38/1659 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	andl	');  EmitAdrMode( AT2.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 39 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2]^.son[1],nest+1,AT1 );
  EmitNtSimpleVariable(e^.son[2]^.son[2]^.son[1],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 39/1678 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	xorl	');  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 40 :
  EmitNtSimpleVariable(e^.son[1],nest+1,AT0 );
  EmitNtSimpleVariable(e^.son[2]^.son[1]^.son[1],nest+1,AT1 );
  EmitNtRegOrIm(e^.son[2]^.son[2],nest+1,AT2 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 40/1678 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	EmitIndex (e^.son[1]^.gcg^.SimpleVariable.base, e^.son[1]^.gcg^.SimpleVariable.index, RegAlloc.allocation[1].scr[1]);
 CodeGen.EmitString('	xorl	');  EmitAdrMode( AT2.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( e^.son[1]^.gcg^.SimpleVariable.base);  CodeGen.EmitLn;

     | 41 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2]^.son[1],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 41/1804 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	GetLabel(lab);
 CodeGen.EmitString('	fcoml	TwoExp31_');  CodeGen.EmitLn;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	jb	');  CodeGen.EmitString( lab^);  CodeGen.EmitLn;
 CodeGen.EmitString('	fsubl	TwoExp32_');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
	CheckRoundMode2 (RndZero, RndNegInf);
 CodeGen.EmitString('	fistpl	');  EmitMemAdr( AT0.mem.am );  CodeGen.EmitLn;
	PopFStack;

     | 42 :
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 42/2171 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' PlaceLabel');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString( e^.attr^.PlaceLabel.lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;

     | 43 :
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 43/2178 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Goto');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	jmp	');  CodeGen.EmitString( e^.attr^.Goto.tar^);  CodeGen.EmitLn;

     | 44 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 44/2185 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SwitchL');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	GetLabel (lab);
 CodeGen.EmitString('	.data');  CodeGen.EmitLn;
 CodeGen.EmitString('	.align 4');  CodeGen.EmitLn;
 CodeGen.EmitString( lab^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
	WHILE e^.attr^.SwitchL.CaseLabels # NIL DO
 CodeGen.EmitString('	.long	');  CodeGen.EmitString( e^.attr^.SwitchL.CaseLabels^.label^);  CodeGen.EmitLn;
	  e^.attr^.SwitchL.CaseLabels := e^.attr^.SwitchL.CaseLabels^.next;
	END;
 CodeGen.EmitString('	.text');  CodeGen.EmitLn;
	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	sub');  EmitSuffix( e^.attr^.SwitchL.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( e^.attr^.SwitchL.lwb);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.SwitchL.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[RelLess][SignedTable[e^.attr^.SwitchL.mode]]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.SwitchL.DefaultLabel^);  CodeGen.EmitLn;
 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.SwitchL.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( e^.attr^.SwitchL.upb - e^.attr^.SwitchL.lwb);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.SwitchL.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[RelGreater][SignedTable[e^.attr^.SwitchL.mode]]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.SwitchL.DefaultLabel^);  CodeGen.EmitLn;
 CodeGen.EmitString('	jmp	*');  CodeGen.EmitString( lab^);  CodeGen.EmitString('(,');  EmitRegister(RegAlloc.allocation[1].op[1]);  CodeGen.EmitString(',4)');  CodeGen.EmitLn;

     | 45 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 45/2206 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.TestAndBranch.cond THEN k:=1 ELSE k:=0 END;
	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	cmpb	$');  CodeGen.EmitInt( k);  CodeGen.EmitChar(',');  EmitByteRegister ( RegAlloc.allocation[1].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	je	');  CodeGen.EmitString( e^.attr^.TestAndBranch.tar^);  CodeGen.EmitLn;

     | 46 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 46/2215 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF e^.attr^.TestAndBranch.cond THEN k:=1 ELSE k:=0 END;
	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	cmpb	$');  CodeGen.EmitInt( k);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	je	');  CodeGen.EmitString( e^.attr^.TestAndBranch.tar^);  CodeGen.EmitLn;

     | 47 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 47/2224 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.FixedCompareAndBranch.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.FixedCompareAndBranch.mode);  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[e^.attr^.FixedCompareAndBranch.rel][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.FixedCompareAndBranch.tar^);  CodeGen.EmitLn;

     | 48 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
  EmitNtRegOrIm(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 48/2232 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.FixedCompareAndBranch.mode);  CodeGen.EmitTab;  EmitAdrMode( AT1.RegOrIm.am);  CodeGen.EmitChar(',');  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[e^.attr^.FixedCompareAndBranch.rel][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.FixedCompareAndBranch.tar^);  CodeGen.EmitLn;

     | 49 :
  EmitNtConstant(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 49/2240 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FixedCompareAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	cmp');  EmitSuffix( e^.attr^.FixedCompareAndBranch.mode);  CodeGen.EmitString('	$');  CodeGen.EmitInt( e^.son[1]^.gcg^.Constant.val);  CodeGen.EmitChar(',');  EmitAdrMode( AT1.RegOrCMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[Reverse[e^.attr^.FixedCompareAndBranch.rel]][SignedTable[e^.attr^.FixedCompareAndBranch.mode]]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.FixedCompareAndBranch.tar^);  CodeGen.EmitLn;

     | 50 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
  EmitNtCMem(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 50/2248 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	fcomp');  EmitSuffix( e^.son[2]^.gcg^.CMem.mode);  CodeGen.EmitTab;  EmitMemAdr( AT1.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[e^.attr^.FloatCompareAndBranch.rel][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.FloatCompareAndBranch.tar^);  CodeGen.EmitLn;
	PopFStack;

     | 51 :
  EmitNtCMem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 51/2260 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	fcomp');  EmitSuffix( e^.son[1]^.gcg^.CMem.mode);  CodeGen.EmitTab;  EmitMemAdr( AT0.CMem.am);  CodeGen.EmitLn;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[Reverse[e^.attr^.FloatCompareAndBranch.rel]][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.FloatCompareAndBranch.tar^);  CodeGen.EmitLn;
	PopFStack;

     | 52 :
  EmitNtfstack(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 52/2272 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' FloatCompareAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
	INC (FStackStart);
	IF FStackTempo[FStackStart] # NoTempo THEN
 CodeGen.EmitString('	fcompl	');  CodeGen.EmitInt( FStackTempo[FStackStart]);  CodeGen.EmitString('(%ebp)');  CodeGen.EmitLn;
	  DEC (CurFStackSize);
	ELSE
 CodeGen.EmitString('	fcompp');  CodeGen.EmitLn;
	  DEC (CurFStackSize, 2);
	END;
 CodeGen.EmitString('	fstsw	%ax');  CodeGen.EmitLn;
 CodeGen.EmitString('	sahf');  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[Reverse[e^.attr^.FloatCompareAndBranch.rel]][SignedTable[e^.attr^.FloatCompareAndBranch.mode]]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.FloatCompareAndBranch.tar^);  CodeGen.EmitLn;

     | 53 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 53/2290 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SetCompareAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	cmpl	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[e^.attr^.SetCompareAndBranch.rel][FALSE]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.SetCompareAndBranch.tar^);  CodeGen.EmitLn;

     | 54 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMemOrIm(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 54/2299 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' SetCompareAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	movl	');  EmitRegister(RegAlloc.allocation[1].op[1]);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
	CASE e^.attr^.SetCompareAndBranch.rel OF
	| RelLess:
 CodeGen.EmitString('	or	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
	e^.attr^.SetCompareAndBranch.rel := RelUnequal;
	| RelLessOrEqual:
 CodeGen.EmitString('	and	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
	e^.attr^.SetCompareAndBranch.rel := RelEqual;
	| RelGreater:
 CodeGen.EmitString('	and	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
	e^.attr^.SetCompareAndBranch.rel := RelUnequal;
	| RelGreaterOrEqual:
 CodeGen.EmitString('	or	');  EmitAdrMode( AT1.RegOrCMemOrIm.am);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitLn;
	e^.attr^.SetCompareAndBranch.rel := RelEqual;
	END;
 CodeGen.EmitString('	cmpl	');  EmitRegister(RegAlloc.allocation[1].scr[1]);  CodeGen.EmitChar(',');  EmitRegister(RegAlloc.allocation[1].op[1]);  CodeGen.EmitLn;
 CodeGen.EmitString('	j');  CodeGen.EmitString( RelationTable[e^.attr^.SetCompareAndBranch.rel][FALSE]);  CodeGen.EmitTab;  CodeGen.EmitString( e^.attr^.SetCompareAndBranch.tar^);  CodeGen.EmitLn;

     | 55 :
  EmitNtRegOrIm(e^.son[1],nest+1,AT0 );
  EmitNtRegOrCMem(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 55/2331 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestMembershipAndBranchL');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	btl	');  EmitAdrMode( AT0.RegOrIm.am);  CodeGen.EmitChar(',');  EmitAdrMode( AT1.RegOrCMem.am);  CodeGen.EmitLn;
	IF e^.attr^.TestMembershipAndBranchL.cond THEN
 CodeGen.EmitString('	jc	');  CodeGen.EmitString( e^.attr^.TestMembershipAndBranchL.tar^);  CodeGen.EmitLn;
	ELSE
 CodeGen.EmitString('	jnc	');  CodeGen.EmitString( e^.attr^.TestMembershipAndBranchL.tar^);  CodeGen.EmitLn;
	END;

     | 56 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 56/2343 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' TestOddAndBranch');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	and');  EmitSuffix( e^.attr^.TestOddAndBranch.mode);  CodeGen.EmitString('	$1,');  EmitRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.TestOddAndBranch.mode);  CodeGen.EmitLn;
	IF NOT e^.attr^.TestOddAndBranch.cond THEN
 CodeGen.EmitString('	xor');  EmitSuffix( e^.attr^.TestOddAndBranch.mode);  CodeGen.EmitString('	$1,');  EmitRegister2 ( RegAlloc.allocation[1].op[1],e^.attr^.TestOddAndBranch.mode);  CodeGen.EmitLn;
	END;
 CodeGen.EmitString('	jnz	');  CodeGen.EmitString( e^.attr^.TestOddAndBranch.tar^);  CodeGen.EmitLn;

     | 57 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
  EmitNtreg(e^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 57/2483 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ProcedureCall');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	call	');  EmitRegister(RegAlloc.allocation[1].op[2]);  CodeGen.EmitLn;
	IF e^.attr^.ProcedureCall.paramsize # 0 THEN
	(* e^.attr^.ProcedureCall.paramsize := (e^.attr^.ProcedureCall.paramsize+3) DIV 4 * 4; *)
 CodeGen.EmitString('	addl	$');  CodeGen.EmitInt( e^.attr^.ProcedureCall.paramsize);  CodeGen.EmitString(', %esp');  CodeGen.EmitLn;
	END;

     | 58 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 58/2495 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ProcedureCall');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
 CodeGen.EmitString('	call	');  CodeGen.EmitString( e^.son[2]^.attr^.ProcedureConstant.index^.Entry^);  CodeGen.EmitLn;
	IF e^.attr^.ProcedureCall.paramsize # 0 THEN
	(* e^.attr^.ProcedureCall.paramsize := (e^.attr^.ProcedureCall.paramsize+3) DIV 4 * 4; *)
 CodeGen.EmitString('	addl	$');  CodeGen.EmitInt( e^.attr^.ProcedureCall.paramsize);  CodeGen.EmitString(', %esp');  CodeGen.EmitLn;
	END;

     | 59 :
  EmitNtarglist(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 59/2567 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' RTSCall');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CurRoundMode := RndUnknown;
	CASE e^.attr^.RTSCall.sysproc OF
	      | SysProcHALT :
 CodeGen.EmitString('	call	exit_');  CodeGen.EmitLn;
	      | SysProcTransfer :
 CodeGen.EmitString('	call	Transfer_');  CodeGen.EmitLn;
	      | SysProcNewprocess :
 CodeGen.EmitString('	call	NewProcess_');  CodeGen.EmitLn;
	      | SysProcCaseError :
 CodeGen.EmitString('	call	CaseErr_');  CodeGen.EmitLn;
	      | SysProcReturnError :
 CodeGen.EmitString('	call	ReturnErr_');  CodeGen.EmitLn;
	END;
	IF e^.attr^.RTSCall.paramsize # 0 THEN
	(* e^.attr^.RTSCall.paramsize := (e^.attr^.RTSCall.paramsize+3) DIV 4 * 4; *)
 CodeGen.EmitString('	addl	$');  CodeGen.EmitInt( e^.attr^.RTSCall.paramsize);  CodeGen.EmitString(', %esp');  CodeGen.EmitLn;
	END;

     | 60 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2]^.son[1]^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 60/2791 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CheckRoundMode (RndNegInf);
 CodeGen.EmitString('	fistpl	');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;
	PopFStack;

     | 61 :
  EmitNtmem(e^.son[1],nest+1,AT0 );
  EmitNtfreg(e^.son[2]^.son[1]^.son[2],nest+1,AT1 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 61/2831 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Assign');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	CheckRoundMode (RndZero);
 CodeGen.EmitString('	fistpl	');  EmitMemAdr( AT0.mem.am);  CodeGen.EmitLn;
	PopFStack;

     | 62 :
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 62/2848 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' BeginProcedure');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

   UndefOperand := IR.emptyExpression;
   CurLevel := e^.attr^.BeginProcedure.level;
   CurFrameSize := 4 * ((ABS(e^.attr^.BeginProcedure.FrameSize)+3) DIV 4);
   CurRoundMode := RndUnknown;
   IF CurLevel > MaxDisplay THEN
      ERROR ('too many nested procedures', CurPos);
      CurLevel := 0;
   END;
   CurFStackSize := 0;
   FStackStart := MaxFloatTempo;
   TransferTempo := NoTempo;

(* -------------------------------------------------------------------- *)
(* Die Daten werden bei Prozeduren wie folgt auf dem Stack abgelegt :	*)
(*		------------------------- <--- Stackanfang (MaxAdr)	*)
(*		|			|				*)
(*		|	.......		|				*)
(*		|			|				*)
(*	    .	|-----------------------|				*)
(*	    .	|	Parameter	|				*)
(*	    .	| (bei OpenArrays nur	|				*)
(*	    8	|  Adresse und Laenge)	|				*)
(*		|-----------------------|				*)
(*	    4	|    Return-Adresse	|				*)
(*		|-----------------------|				*)
(*	    0	|   alter BasePointer   | <--- BasePointer (ebp)	*)
(*		|-----------------------|   )				*)
(*	   -4	| alter DV [CurLevel]	|   )				*)
(*		|-----------------------|   )				*)
(*	   -8	| lokale Variablen	|   )  Activation Record (AR)	*)
(*	    .	|-----------------------|   )				*)
(*	    .	| evtl.temporaere Werte	|   )				*)
(*	    .	|-----------------------|   )				*)
(*		| evtl. OpenArrays	|   )				*)
(*		|-----------------------|   )				*)
(*		| Platz fuer Sicherungen|   )				*)
(*		|-----------------------| <--- StackPointer (esp)	*)
(*									*)
(* Der DisplayVector DV enthaelt jeweils den aktuellen BP der zuletzt	*)
(* auf dem jeweiligen Level ausgefuehrten Prozedur.			*)
(* Der DisplayVector steht ab der Stelle DISPLAY_ im Speicher,		*)
(* durch das sich die Adresse vom DisplayVector des Levels i, also	*)
(* DV [i], als DISPLAY_ + i*4 errechnen laesst.				*)
(* Aus Optimierungsgruenden wird jedoch der DV nicht in jedem Level	*)
(* gespeichert und geladen, sondern nur, falls eine Prozedur des Levels *)
(* i auf eine nicht-globale Variable des Levels j (j < i) zugreift.	*)
(* -------------------------------------------------------------------- *)

(* Zunaechst den Label bestimmen, an dem der die Groesse des Activation *)
(* Records bei EndProcedure gespeichert wird. Diese kann durch die un-	*)
(* gewisse Zahl der benoetigten temporaeren Werte erst am Schluss	*)
(* bestimmt werden.							*)
	GetLabel (ProcLabel);
(* Startlabel der Prozedur eintragen *)
 CodeGen.EmitString('	.align 4');  CodeGen.EmitLn;
 CodeGen.EmitString( e^.attr^.BeginProcedure.index^.Entry^);  CodeGen.EmitChar(':');  CodeGen.EmitLn;
(* Alten BP sichern *)
 CodeGen.EmitString('	pushl	%ebp');  CodeGen.EmitLn;
(* Neuer BP fuer neuen Activation Record *)
 CodeGen.EmitString('	movl	%esp,%ebp');  CodeGen.EmitLn;
(* Platz fuer alten DisplayVector[CurLevel], lokale Variablen und	*)
(* temporaere Werte schaffen.						*)
 CodeGen.EmitString('	subl	$');  CodeGen.EmitString( ProcLabel^);  CodeGen.EmitString(', %esp');  CodeGen.EmitLn;
     IF SaveDisplay [CurLevel] THEN
(* Aktualisieren des DisplayVectors,  wird fuer andere Prozedur benoetigt. *)
(* Laden des momentanen DisplayVectors [CurLevel] *)
 CodeGen.EmitString('	movl	DISPLAY_+');  CodeGen.EmitInt( 4 * CurLevel);  CodeGen.EmitString(',%ecx');  CodeGen.EmitLn;
(* Sichern des alten Wertes des DisplayVectors [CurLevel] *)
 CodeGen.EmitString('	movl	%ecx,-4(%ebp)');  CodeGen.EmitLn;
(* Schreiben des aktuellen DisplayVectors [CurLevel] *)
 CodeGen.EmitString('	movl	%ebp,DISPLAY_+');  CodeGen.EmitInt( 4 * CurLevel);  CodeGen.EmitLn;
     END;

(* !!!!!!!!!! Registersicherung bei Funktionsaufrufen !!!!!!!!!!
   Linux/BSD: edi, esi, ebx werden in aufgerufener Funktion gesichert,
	      ecx, edx werden in aufrufender Funktion gesichert,
	      eax oder st behinhaltet den Rueckgabewert
   MOCKA:     edi, esi, ebx, ecx, edx werden in aufrufender Funktion gesichert,
	      eax oder st behinhaltet den Rueckgabewert
   Dieser Unterschied ist unwesentlich bei Aufruf von C-Funktionen
   (z.B. libc) aus MOCKA-Programmen. Im umgekehrten Fall (Aufruf von MOCKA-
   Funktionen von C aus, z.B. von atexit-Funktionen) fuehrt dies zu Fehlern.
   Abhilfe: Die CcallsMocka Option
   Diese sichert immer edi, esi, ebx, egal ob sie veraendert werden oder
   nicht (was genau geaendert wird, weiss man bei einem 1-Pass Compiler
   leider nicht). Dies ist im Normalfall ueberfluessig, und sollte daher
   aus Performancegruenden auf die Funktionen beschraenkt werden, die
   von C aus aufgerufen werden.						*)
     IF Enabled (oCCall) THEN
 CodeGen.EmitString('	pushl %edi');  CodeGen.EmitLn;
 CodeGen.EmitString('	pushl %esi');  CodeGen.EmitLn;
 CodeGen.EmitString('	pushl %ebx');  CodeGen.EmitLn;
     END;

     IF EmitAnnotations THEN
 CodeGen.EmitString('	/* --------------------------------------------------------- */');  CodeGen.EmitLn;
 CodeGen.EmitString('	/* Level : ');  CodeGen.EmitInt( CurLevel);  CodeGen.EmitString(' */');  CodeGen.EmitLn;
 CodeGen.EmitString('	/* --------------------------------------------------------- */');  CodeGen.EmitLn;
     END;

     | 63 :
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 63/2952 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' CopyOpenArray');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF EmitAnnotations THEN
 CodeGen.EmitString('	/* Copy Open Array Begin */');  CodeGen.EmitLn;
	END;
   IF (e^.attr^.CopyOpenArray.elemsize # ByteSize) & ODD (e^.attr^.CopyOpenArray.elemsize) THEN INC (e^.attr^.CopyOpenArray.elemsize); END;
   (* Lade letzten Index (= Laenge - 1) des Stringparameter *)
 CodeGen.EmitString('	movl	');  CodeGen.EmitInt( e^.attr^.CopyOpenArray.HighOffset);  CodeGen.EmitString('(%ebp),%ecx');  CodeGen.EmitLn;
   (* Bestimme Laenge des Stringparameters *)
 CodeGen.EmitString('	incl	%ecx');  CodeGen.EmitLn;
   (* Ermittle Platzbedarf fuer den Stringparameter.			*)
   (* Das Resultat steht in Register ecx.				*)
      IF e^.attr^.CopyOpenArray.elemsize # ByteSize THEN
      (* Multiplikation Elementanzahl * Elementgroesse = Platzbedarf	*)
      (* durchfuehren.							*)
	 IF IsPowerOfTwo (e^.attr^.CopyOpenArray.elemsize) THEN
 CodeGen.EmitString('	shll	$');  CodeGen.EmitInt( Log2 (e^.attr^.CopyOpenArray.elemsize));  CodeGen.EmitString(', %ecx');  CodeGen.EmitLn;
	 ELSE
 CodeGen.EmitString('	imull	$');  CodeGen.EmitInt( e^.attr^.CopyOpenArray.elemsize);  CodeGen.EmitString(',%ecx');  CodeGen.EmitLn;
	 END
      END;
   (* Platzbedarf auf durch 4 teilbare Adresse aufrunden *)
 CodeGen.EmitString('	addl	$3,%ecx');  CodeGen.EmitLn;
 CodeGen.EmitString('	andl	$0xfffffffc, %ecx');  CodeGen.EmitLn;
   (* Schaffe auf dem Stack entsprechenden Platz *)
 CodeGen.EmitString('	subl 	%ecx,%esp');  CodeGen.EmitLn;
   (* Startadresse des zu kopierenden ARRAYs				*)
 CodeGen.EmitString('	movl	%esp,%edi');  CodeGen.EmitLn;
   (* Lade Startadresse des OpenArrays *)
 CodeGen.EmitString('	movl	');  CodeGen.EmitInt( e^.attr^.CopyOpenArray.DataOffset);  CodeGen.EmitString('(%ebp),%esi');  CodeGen.EmitLn;
    (* Ersetze im Parameterteil der Prozedur die Startadresse des Parameter-
       strings durch die Adresse dessen Kopie auf das OpenArray         *)
 CodeGen.EmitString('	movl	%edi,');  CodeGen.EmitInt( e^.attr^.CopyOpenArray.DataOffset);  CodeGen.EmitString('(%ebp)');  CodeGen.EmitLn;
     (* Kopiere Stringparameter in den OpenArray-Platz der Prozedur     *)
     (* Register ecx enthaelt die Groesse				*)
     (* Register esi die Quelladresse,					*)
     (* Register edi die Zieladresse.					*)
 CodeGen.EmitString('	shrl	$2,%ecx');  CodeGen.EmitLn;
 CodeGen.EmitString('	cld');  CodeGen.EmitLn;
 CodeGen.EmitString('	repz');  CodeGen.EmitLn;
 CodeGen.EmitString('	movsl');  CodeGen.EmitLn;
	IF EmitAnnotations THEN
 CodeGen.EmitString('	/* Copy Open Array End */');  CodeGen.EmitLn;
	END;

     | 64 :
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 64/3000 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Return');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	IF (CurFStackSize <> 0) AND OK THEN
 CodeGen.EmitString('	ERROR: CurFStackSize <> 0');  CodeGen.EmitLn;
	CodeGen.Close;
	CompilerError ("Something's going wrong in fp expression");
	END;
	CurRoundMode := RndUnknown;
	IF SaveDisplay [CurLevel] THEN
	(* Alten Wert von DisplayVector [CurLevel] laden, wurde veraendert *)
 CodeGen.EmitString('	movl	-4(%ebp),%ecx');  CodeGen.EmitLn;
	(* Diesen Wert wieder in DisplayVector [CurLevel] eintragen *)
 CodeGen.EmitString('	movl	%ecx,DISPLAY_+');  CodeGen.EmitInt( 4 * CurLevel);  CodeGen.EmitLn;
	END;
	(* Bei Aufruf von MOCKA Prozeduren von C Programmen
	   (z.B. atexitHandler) muessen diese in BeginProcedure
	   gesicherten Register wiederhergestellt werden. *)
	IF Enabled (oCCall) THEN
 CodeGen.EmitString('	popl %ebx');  CodeGen.EmitLn;
 CodeGen.EmitString('	popl %esi');  CodeGen.EmitLn;
 CodeGen.EmitString('	popl %edi');  CodeGen.EmitLn;
	END;
	(* Ruecksprung aus der Prozedur *)
 CodeGen.EmitString('	leave');  CodeGen.EmitLn;
 CodeGen.EmitString('	ret');  CodeGen.EmitLn;

     | 65 :
  EmitNtreg(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 65/3033 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ReturnValueL');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

     | 66 :
  EmitNtfreg(e^.son[1],nest+1,AT0 );
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 66/3036 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' ReturnValueL');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	PopFStack;

     | 67 :
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 67/3042 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' EndProcedure');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

	SaveDisplay [CurLevel] := FALSE;
	CurFrameSize :=   4 * ((ABS(CurFrameSize)+3) DIV 4);
 CodeGen.EmitTab;  CodeGen.EmitString( ProcLabel^);  CodeGen.EmitString(' = ');  CodeGen.EmitInt( CurFrameSize);  CodeGen.EmitLn;

     | 68 :
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 68/3052 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' EndModule');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;

   CodeGen.Close;
   IF OK (* no Errors *) THEN
      StringAssign  (cmd, 'cd ');
      StringAppend2 (cmd, LibraryDirectory, '; ');
      StringAppend1 (cmd, AssemblerScript);
      IF Enabled (ElfOption) THEN
	 StringAppend1 (cmd,' -elf');
      END;
      IF Enabled (DebugOption) THEN
	 StringAppend1 (cmd,' -g');
      END;
      StringAppend2 (cmd, ' ', ModName);
      SystemCommand (cmd,ok);
      IF NOT ok THEN
	 WriteString ("Assembler terminated with error"); WriteLn;
	 exit (1);
      END;
   END;
   IF NOT Enabled (oAssemblerListing) THEN
      Erase (AsmListFileName,ok);
   END;

     | 69 :
    IF (RegAlloc.allocation [1]. num>0) THEN
       PerformActions (1);
    END;
    IF IR.OptEmitMatch THEN
       WriteNest (nest);
       WriteString ('Rule 69/3078 Cost=');
       WriteInt    (e^.gcg^.stmtcost,1);
       WriteString (' Mark');
       WriteLn;
       WriteNest (nest);
       IF e#NIL THEN IR.PrintAttributes (e^.attr^); END; WriteLn;
       WriteNest (nest);
       RegAlloc.PrintAllocation (1); WriteLn;
    END;
 CurPos.line := e^.attr^.Mark.line; CurPos.col := e^.attr^.Mark.col;
    END;
  END;
END EmitStatement;


(* ------------------------------------------------------------------------
 * Procedure EmitInstruction  --  needs clean up
 * ------------------------------------------------------------------------ *)

PROCEDURE EmitInstruction ( e : IR.Expression );
BEGIN
   IF IR.OptEmitIR THEN IR.PrintExpression (e); END;
(*++++++ start insertion IpEmitI1 ++++++*)

      localavail[0] := { ORD (Regeax)-0,  ORD (Regebx)-0,  ORD (Regecx)-0,  ORD (Regedx)-0,  ORD (Regesi)-0,  ORD (Regedi)-0,  ORD (Regst)-0, ORD (Regst1)-0};


(*------ end   insertion IpEmitI1 ------*)
   RegAlloc.RegAllo (e, localavail);
(******* empty insertion IpEmitI2 *******)
   EmitStatement (e);
END EmitInstruction;



(* MODULE Initialisation *)

VAR
  RegisterSetEmpty : RegisterSet;

BEGIN (* Emit *)
  RegisterSetEmpty [0] := {};

(*++++++ start insertion IpEmitInit ++++++*)

    SizeTable [UnsignedByte] := ByteSize;
    SizeTable [UnsignedWord] := WordSize;
    SizeTable [UnsignedLong] := LongSize;
    SizeTable [SignedByte]   := ByteSize;
    SizeTable [SignedWord]   := WordSize;
    SizeTable [SignedLong]   := LongSize;
    SizeTable [FloatShort]   := SizeREAL;
    SizeTable [FloatLong]    := SizeLONGREAL;

    SuffixTable [UnsignedByte] := 'b';
    SuffixTable [UnsignedWord] := 'w';
    SuffixTable [UnsignedLong] := 'l';
    SuffixTable [SignedByte]   := 'b';
    SuffixTable [SignedWord]   := 'w';
    SuffixTable [SignedLong]   := 'l';
    SuffixTable [FloatShort]   := 's';
    SuffixTable [FloatLong]    := 'l';

    SignedTable [UnsignedByte] := FALSE;
    SignedTable [UnsignedWord] := FALSE;
    SignedTable [UnsignedLong] := FALSE;
    SignedTable [SignedByte]   := TRUE;
    SignedTable [SignedWord]   := TRUE;
    SignedTable [SignedLong]   := TRUE;
    SignedTable [FloatShort]   := FALSE;
    SignedTable [FloatLong]    := FALSE;

    RelationTable [RelEqual]	     [FALSE] := 'e';
    RelationTable [RelUnequal]	     [FALSE] := 'ne';
    RelationTable [RelLess]	     [FALSE] := 'b';
    RelationTable [RelLessOrEqual]   [FALSE] := 'be';
    RelationTable [RelGreater]	     [FALSE] := 'a';
    RelationTable [RelGreaterOrEqual][FALSE] := 'ae';
    RelationTable [RelEqual]	     [TRUE ] := 'e';
    RelationTable [RelUnequal]	     [TRUE ] := 'ne';
    RelationTable [RelLess]	     [TRUE ] := 'l';
    RelationTable [RelLessOrEqual]   [TRUE ] := 'le';
    RelationTable [RelGreater]	     [TRUE ] := 'g';
    RelationTable [RelGreaterOrEqual][TRUE ] := 'ge';

    Reverse [RelEqual]		:= RelEqual;
    Reverse [RelUnequal]	:= RelUnequal;
    Reverse [RelLess]		:= RelGreater;
    Reverse [RelLessOrEqual]	:= RelGreaterOrEqual;
    Reverse [RelGreater]	:= RelLess;
    Reverse [RelGreaterOrEqual]	:= RelLessOrEqual;

    PowerTable [0] := 1;
    FOR i := 1 TO MaxPowerTable DO PowerTable [i] := 2 * PowerTable [i-1] END;

    WordReg[Regeax] := '%ax';
    WordReg[Regebx] := '%bx';
    WordReg[Regecx] := '%cx';
    WordReg[Regedx] := '%dx';
    WordReg[Regesi] := '%si';
    WordReg[Regedi] := '%di';
    ByteReg[Regeax] := '%al';
    ByteReg[Regebx] := '%bl';
    ByteReg[Regecx] := '%cl';
    ByteReg[Regedx] := '%dl';

    DefineOption (oEmitIR, 'EmitIR', FALSE, FALSE);
    DefineOption (oEmitMatch, 'EmitMatch', FALSE, FALSE);
    DefineOption (oRegAlloc, 'RegAlloc', FALSE, FALSE);
    DefineOption (oCCall, 'CcallsMocka', FALSE, FALSE);
    DefineOption (ElfOption, 'elf', FALSE, TRUE);
    DefineOption (oAssemblerListing, 'S', FALSE, TRUE);
(*------ end   insertion IpEmitInit ------*)
END Emit.
